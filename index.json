[{"content":"使用中科大镜像源加速 Conda 由于 Windows 文件系统限制，无法在资源管理器中直接创建名为 .condarc 的文件，可先执行 conda config --set show_channel_urls yes，该命令将在用户目录 $HOME 下生成 .condarc 文件。\n打开 $HOME/.condarc 文件，将内容修改为：\nssl_verify: false show_channel_urls: true channels: - https://mirrors.ustc.edu.cn/anaconda/pkgs/main - https://mirrors.ustc.edu.cn/anaconda/pkgs/r - https://mirrors.ustc.edu.cn/anaconda/pkgs/msys2 - defaults 保存后重启终端配置即可生效，执行 conda clean -i 清理缓存。\n使用中科大镜像加速 pip 执行 pip config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple，该命令会生成 $HOME/AppData/Roaming/pip/pip.ini 文件，重启终端配置即可生效。\n ** pip install 安装包时提示 SSL 错误**\n添加信任的主机，编辑 $HOME/AppData/Roaming/pip/pip.ini，替换为：\n[global] index-url = https://mirrors.ustc.edu.cn/pypi/web/simple trusted-host = pypi.python.org mirrors.ustc.edu.cn  ","permalink":"https://leslievan.github.io/2021/11/accelerate-all/","summary":"使用中科大镜像源加速 Conda 由于 Windows 文件系统限制，无法在资源管理器中直接创建名为 .condarc 的文件，可先执行 conda config --set show_channel_urls yes，该命令将在用户目录 $HOME 下生成 .condarc 文件。","title":"「镜像」使用镜像源加速常用的软件"},{"content":"编码中经常有让某个窗口置顶的需求，之前使用 Linux 时，GNOME 之类的桌面环境大多都可以通过右键单击标题栏来开启该窗口的置顶，换到 Windows 下面没这个功能反而不太适应了，研究了下 AutoHotKey 发现使用它可以更加灵活地开关窗口置顶.\n使用方法 自主编译   安装 AutoHotKey v2.\n AutoHotKey 官网下载安装包，解压到指定的路径，如 D:\\AutoHotKey.    下载/编写 ahk 文件.\nwindowOnTop.ahk\n; # 表示 Win 键，#Space 表示使用 Win+Space 切换窗口置顶的功能 #Space:: { WinSetAlwaysOnTop -1, \u0026quot;A\u0026quot; Return }   使用 AutoHotKey32/64.exe 打开 windowOnTop.ahk 文件.\n  右键单击打开方式，如选择使用 D:\\AutoHotKey\\AutoHotKey64.exe 打开。\n  拖动 windowOnTop.ahk 到 AutoHotKey64.exe 上打开。\n  以上两种方式任选一种即可。\n  当看到托盘处出现 AutoHotKey 的图标即表示激活成功，使用 Win+空格 即可切换窗口是否置顶。\n使用 exe 文件   在 Release 中下载使用 Ahk2Exe 编译好的可执行文件。\n  执行 exe 文件。\n  当看到托盘处出现 AutoHotKey 的图标即表示激活成功，使用 Win+空格 即可切换窗口是否置顶。\n","permalink":"https://leslievan.github.io/2021/11/ahk-windows-set-top/","summary":"编码中经常有让某个窗口置顶的需求，之前使用 Linux 时，GNOME 之类的桌面环境大多都可以通过右键单击标题栏来开启该窗口的置顶，换到 Windows 下面没这个功能","title":"「AutoHotKey」快速切换窗口置顶"},{"content":"问题描述 自然语言\n 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和.\nLeetCode 53. 最大子序和\n 示例 1\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 . 示例 2\n输入：nums = [1] 输出：1 示例 3\n输入：nums = [0] 输出：0 示例 4\n输入：nums = [-1] 输出：-1 示例 5\n输入：nums = [-100000] 输出：-100000 解题思路 暴力解法 穷举出子数组的所有可能性，依次计算它们的和，并求得最大值.不难得出，子数组的个数为 $C_n^2=\\frac{n(n-1)}{2}=\\Theta(n^2)$，计算每个子数组的和可以在线性时间内完成，因此整个算法的复杂度为 $\\Theta(n^3)$\n设输入为 nums[0..high]\n算法简述\nmax = -∞ for i=0 upto high for j=i+1 upto high count = 0 for k=i upto j count += nums[k] if count \u0026gt; max max = count return max 不过我们可以通过记录从前的值，将计算子数组的和这一操作在 $O(1)$ 时间中完成.\n算法简述\nmax = -∞ for i=0 upto high count = 0 for j=i upto high count += num[j] if count \u0026gt; max max = count return max 则此时算法的复杂度将降低到 $\\Theta(n^2)$.\n附录 暴力解法代码实现 public int maxSubArray(int[] nums) { int max = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; nums.length; i++) { int count = 0; for (int j = i; j \u0026lt; nums.length; j++) { count += nums[j]; if (count \u0026gt; max) { max = count; } } } return max; } ","permalink":"https://leslievan.github.io/2021/10/maximum-subarray/","summary":"问题描述 自然语言 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和. LeetCode 53. 最大子序和 示例 1 输入：","title":"「最大子数组」最大子数组问题"},{"content":"\n写算法题的时候经常会碰到一些大数相关的问题，比如大数乘法、大数加法等等，乘法和加法的原理基本上都比较符合正常的思维模式，因为加法和乘法的原理相对清晰，模拟数学计算步骤可以方便地分离，并转换为代码。\n相对于常见的加法和乘法，进制转换出现的频率低一些，但同样是一个十分值得探讨的问题，并且难度较之加法和乘法更高。\n问题抽象   输入为 ($M$, $m$, $n$):\n $M$: $m$ 进制整数 $M$，用字符串类型 string 储存 $m$: 大数基数 $m$ $n$: 大数目的基数 $n$    输出为 N：\n $N$: $n$ 进制整数 $N$，用字符串类型 string 储存    数学原理 $m$ 进制转换成 $n$ 进制，通常采用的是「模 $n$ 取余法」，也称「辗转相除法」，一般数进制转换的方法：\n  输入 $m$ 进制数 $M$ 作为除数，对目标进制基数 $n$ 求整数商得到商 $Q^1$ ，对基数 $n$ 取余得到余数 $R^1$，\n  若商 $Q^1$ 为 $0$，循环终止，否则，用商 $Q^1$ 作为除数，继续对基数 $n$ 求整数商得到商 $Q^2$，取余得到余数 $R^2$，\n  循环第2步，直到商 $Q^t$ 为 $0$，此时得到余数 $R^t$， 则余数序列 $R^tR^{t-1} \\cdots R^1$ 为转换后的 $n$ 进制数 $N$。\n  如 $30 \\to (11110)_2$\n运算过程：\n 30 / 2 = 15, 0​\n15 / 2 = 7, 1​\n7 / 2 = 3, 1​\n3 / 2 = 1, 1\n1 / 2 = 0, 1\n 可以想象，大数转换步骤同样如此。\n问题只在于大数的整数除和取余比一般数字更复杂一些，这里将算法解释如下：\n  设余数 $R=0$\n  由低位至高位，从大数中取数 $M^1$，用余数 $R$ 乘以进制基数 $m$ 后再加上数 $M^1$，得到数 $R \\cdot m + M^1$，用该数对目标进制基数 $n$求整数商得到商 $Q^1$，对基数 $n$ 取余得到新的余数 $R$\n  循环第2步，直至取完大数所有位，得到商 $Q^t$ 和余数 $R$\n则商序列 $Q^tQ^{t-1}\\cdots Q^1$ 为整数商，$R$ 为余数。\n  eg. $(11110)_2 \\to 30$\n   序号 当前位 运算     0 null null   1 1 (0 * 2 + 1) / 10 = 0, 1   2 1 (1 * 2 + 1) / 10 = 0, 3   3 1 (3 * 2 + 1) / 10 = 0, 7   4 1 (7 * 2 + 1) / 10 = 1, 5   5 0 (5 * 2 + 0) / 10 = 1, 0    故商 $(11110)_2/10=(00011)_2=(11)_2$，余数为 $0$\n将 $(11)_2$ 用作下一次循环的运算数\n   序号 当前位 运算     0 null null   1 1 (0 * 2 + 1) / 10 = 0, 0   2 1 (1 * 2 + 1) / 10 = 0, 3    故商 $(11)_2/10=(00)_2=0$，余数为 $3$\n循环结束，得到余数序列 $03$，逆序后得到进制转换后的数 $30$\n代码实现 这里给出 C++ 的算法实现，使用了大量内置的 STL，如不能使用 STL 库可自行实现相关类型。\n#include \u0026#34;string\u0026#34;#include \u0026#34;iostream\u0026#34;#include \u0026#34;vector\u0026#34;#include \u0026#34;algorithm\u0026#34; using namespace std; /** * Mapping a n-base number to a int number * @param c the n-base number * return the int number */ int GetValue(char c) { if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return c - \u0026#39;0\u0026#39;; } if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) { return c - \u0026#39;a\u0026#39; + 10; } if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;A\u0026#39;) { return c - \u0026#39;A\u0026#39; + 36; } return -1; } /** * Convert a big num between different base. * @param a the string of big num * @param src_base the base of origin number, * @param to_base * @return the sring of big num in src_base */ string BaseConvert(string a, int src_base, int to_base = 10) { if (src_base \u0026lt; 2 || src_base \u0026gt; 62 || to_base \u0026lt; 2 || to_base \u0026gt; 62) { return reinterpret_cast\u0026lt;const char *\u0026gt;(1); } char num_alpha[] = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; int temp = 0; vector\u0026lt;int\u0026gt; number, quotient, result; string s; // 将字母映射为数字  for (char \u0026amp;c : a) { number.push_back(GetValue(c)); } auto iter = number.begin(); while (!number.empty()) { // 得到余数和商  while (iter != number.end()) { temp *= src_base; temp += *iter++; quotient.push_back(temp / to_base); temp %= to_base; } // 得到余数，存入result  result.push_back(temp); // 清空商的前置0  auto i = quotient.begin(); while (*i == 0 \u0026amp;\u0026amp; i != quotient.end()) { i++; } if (i != quotient.begin()) { quotient.erase(quotient.begin(), i); } // 将商作为下一次的运算数，重置商数组和temp  number = quotient; quotient.clear(); iter = number.begin(); temp = 0; } // 逆序余数位  reverse(result.begin(), result.end()); // 将数字映射为字母  for (int \u0026amp;i:result) { s += num_alpha[i]; } return s; } int main() { cout \u0026lt;\u0026lt; BaseConvert(\u0026#34;11110\u0026#34;, 2, 10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; BaseConvert(\u0026#34;30\u0026#34;, 10, 2) \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://leslievan.github.io/2020/03/big-number-base-convert/","summary":"写算法题的时候经常会碰到一些大数相关的问题，比如大数乘法、大数加法等等，乘法和加法的原理基本上都比较符合正常的思维模式，因为加法和乘法的原理","title":"「大数问题」大数任意进制转换"}]