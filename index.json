[{"content":"使用中科大镜像源加速 Conda 由于 Windows 文件系统限制，无法在资源管理器中直接创建名为 .condarc 的文件，可先执行 conda config --set show_channel_urls yes，该命令将在用户目录 $HOME 下生成 .condarc 文件。\n打开 $HOME/.condarc 文件，将内容修改为：\nssl_verify: false show_channel_urls: true channels: - https://mirrors.ustc.edu.cn/anaconda/pkgs/main - https://mirrors.ustc.edu.cn/anaconda/pkgs/r - https://mirrors.ustc.edu.cn/anaconda/pkgs/msys2 - defaults 保存后重启终端配置即可生效，执行 conda clean -i 清理缓存。\n使用中科大镜像加速 pip 执行 pip config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple，该命令会生成 $HOME/AppData/Roaming/pip/pip.ini 文件，重启终端配置即可生效。\n ** pip install 安装包时提示 SSL 错误**\n添加信任的主机，编辑 $HOME/AppData/Roaming/pip/pip.ini，替换为：\n[global] index-url = https://mirrors.ustc.edu.cn/pypi/web/simple trusted-host = pypi.python.org mirrors.ustc.edu.cn  ","permalink":"https://leslievan.github.io/2021/11/accelerate-all/","summary":"使用中科大镜像源加速 Conda 由于 Windows 文件系统限制，无法在资源管理器中直接创建名为 .condarc 的文件，可先执行 conda config --set show_channel_urls yes，该命令将在用户目录 $HOME 下生成 .condarc 文件。","title":"「镜像」使用镜像源加速常用的软件"},{"content":"编码中经常有让某个窗口置顶的需求，之前使用 Linux 时，GNOME 之类的桌面环境大多都可以通过右键单击标题栏来开启该窗口的置顶，换到 Windows 下面没这个功能反而不太适应了，研究了下 AutoHotKey 发现使用它可以更加灵活地开关窗口置顶.\n使用方法 自主编译   安装 AutoHotKey v2.\n AutoHotKey 官网下载安装包，解压到指定的路径，如 D:\\AutoHotKey.    下载/编写 ahk 文件.\nwindowOnTop.ahk\n; # 表示 Win 键，#Space 表示使用 Win+Space 切换窗口置顶的功能 #Space:: { WinSetAlwaysOnTop -1, \u0026quot;A\u0026quot; Return }   使用 AutoHotKey32/64.exe 打开 windowOnTop.ahk 文件.\n  右键单击打开方式，如选择使用 D:\\AutoHotKey\\AutoHotKey64.exe 打开。\n  拖动 windowOnTop.ahk 到 AutoHotKey64.exe 上打开。\n  以上两种方式任选一种即可。\n  当看到托盘处出现 AutoHotKey 的图标即表示激活成功，使用 Win+空格 即可切换窗口是否置顶。\n使用 exe 文件   在 Release 中下载使用 Ahk2Exe 编译好的可执行文件。\n  执行 exe 文件。\n  当看到托盘处出现 AutoHotKey 的图标即表示激活成功，使用 Win+空格 即可切换窗口是否置顶。\n","permalink":"https://leslievan.github.io/2021/11/ahk-windows-set-top/","summary":"编码中经常有让某个窗口置顶的需求，之前使用 Linux 时，GNOME 之类的桌面环境大多都可以通过右键单击标题栏来开启该窗口的置顶，换到 Windows 下面没这个功能","title":"「AutoHotKey」快速切换窗口置顶"},{"content":"问题描述 自然语言\n 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和.\nLeetCode 53. 最大子序和\n 示例 1\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 . 示例 2\n输入：nums = [1] 输出：1 示例 3\n输入：nums = [0] 输出：0 示例 4\n输入：nums = [-1] 输出：-1 示例 5\n输入：nums = [-100000] 输出：-100000 解题思路 暴力解法 穷举出子数组的所有可能性，依次计算它们的和，并求得最大值.不难得出，子数组的个数为 $C_n^2=\\frac{n(n-1)}{2}=\\Theta(n^2)$，计算每个子数组的和可以在线性时间内完成，因此整个算法的复杂度为 $\\Theta(n^3)$\n设输入为 nums[0..high]\n算法简述\nmax = -∞ for i=0 upto high for j=i+1 upto high count = 0 for k=i upto j count += nums[k] if count \u0026gt; max max = count return max 不过我们可以通过记录从前的值，将计算子数组的和这一操作在 $O(1)$ 时间中完成.\n算法简述\nmax = -∞ for i=0 upto high count = 0 for j=i upto high count += num[j] if count \u0026gt; max max = count return max 则此时算法的复杂度将降低到 $\\Theta(n^2)$.\n附录 暴力解法代码实现 public int maxSubArray(int[] nums) { int max = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; nums.length; i++) { int count = 0; for (int j = i; j \u0026lt; nums.length; j++) { count += nums[j]; if (count \u0026gt; max) { max = count; } } } return max; } ","permalink":"https://leslievan.github.io/2021/10/maximum-subarray/","summary":"问题描述 自然语言 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和. LeetCode 53. 最大子序和 示例 1 输入：","title":"「最大子数组」最大子数组问题"},{"content":"\n写算法题的时候经常会碰到一些大数相关的问题，比如大数乘法、大数加法等等，乘法和加法的原理基本上都比较符合正常的思维模式，因为加法和乘法的原理相对清晰，模拟数学计算步骤可以方便地分离，并转换为代码。\n相对于常见的加法和乘法，进制转换出现的频率低一些，但同样是一个十分值得探讨的问题，并且难度较之加法和乘法更高。\n问题抽象   输入为 ($M$, $m$, $n$):\n $M$: $m$ 进制整数 $M$，用字符串类型 string 储存 $m$: 大数基数 $m$ $n$: 大数目的基数 $n$    输出为 N：\n $N$: $n$ 进制整数 $N$，用字符串类型 string 储存    数学原理 $m$ 进制转换成 $n$ 进制，通常采用的是「模 $n$ 取余法」，也称「辗转相除法」，一般数进制转换的方法：\n  输入 $m$ 进制数 $M$ 作为除数，对目标进制基数 $n$ 求整数商得到商 $Q^1$ ，对基数 $n$ 取余得到余数 $R^1$，\n  若商 $Q^1$ 为 $0$，循环终止，否则，用商 $Q^1$ 作为除数，继续对基数 $n$ 求整数商得到商 $Q^2$，取余得到余数 $R^2$，\n  循环第2步，直到商 $Q^t$ 为 $0$，此时得到余数 $R^t$， 则余数序列 $R^tR^{t-1} \\cdots R^1$ 为转换后的 $n$ 进制数 $N$。\n  如 $30 \\to (11110)_2$\n运算过程：\n 30 / 2 = 15, 0​\n15 / 2 = 7, 1​\n7 / 2 = 3, 1​\n3 / 2 = 1, 1\n1 / 2 = 0, 1\n 可以想象，大数转换步骤同样如此。\n问题只在于大数的整数除和取余比一般数字更复杂一些，这里将算法解释如下：\n  设余数 $R=0$\n  由低位至高位，从大数中取数 $M^1$，用余数 $R$ 乘以进制基数 $m$ 后再加上数 $M^1$，得到数 $R \\cdot m + M^1$，用该数对目标进制基数 $n$求整数商得到商 $Q^1$，对基数 $n$ 取余得到新的余数 $R$\n  循环第2步，直至取完大数所有位，得到商 $Q^t$ 和余数 $R$\n则商序列 $Q^tQ^{t-1}\\cdots Q^1$ 为整数商，$R$ 为余数。\n  eg. $(11110)_2 \\to 30$\n   序号 当前位 运算     0 null null   1 1 (0 * 2 + 1) / 10 = 0, 1   2 1 (1 * 2 + 1) / 10 = 0, 3   3 1 (3 * 2 + 1) / 10 = 0, 7   4 1 (7 * 2 + 1) / 10 = 1, 5   5 0 (5 * 2 + 0) / 10 = 1, 0    故商 $(11110)_2/10=(00011)_2=(11)_2$，余数为 $0$\n将 $(11)_2$ 用作下一次循环的运算数\n   序号 当前位 运算     0 null null   1 1 (0 * 2 + 1) / 10 = 0, 0   2 1 (1 * 2 + 1) / 10 = 0, 3    故商 $(11)_2/10=(00)_2=0$，余数为 $3$\n循环结束，得到余数序列 $03$，逆序后得到进制转换后的数 $30$\n代码实现 这里给出 C++ 的算法实现，使用了大量内置的 STL，如不能使用 STL 库可自行实现相关类型。\n#include \u0026#34;string\u0026#34;#include \u0026#34;iostream\u0026#34;#include \u0026#34;vector\u0026#34;#include \u0026#34;algorithm\u0026#34; using namespace std; /** * Mapping a n-base number to a int number * @param c the n-base number * return the int number */ int GetValue(char c) { if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) { return c - \u0026#39;0\u0026#39;; } if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) { return c - \u0026#39;a\u0026#39; + 10; } if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;A\u0026#39;) { return c - \u0026#39;A\u0026#39; + 36; } return -1; } /** * Convert a big num between different base. * @param a the string of big num * @param src_base the base of origin number, * @param to_base * @return the sring of big num in src_base */ string BaseConvert(string a, int src_base, int to_base = 10) { if (src_base \u0026lt; 2 || src_base \u0026gt; 62 || to_base \u0026lt; 2 || to_base \u0026gt; 62) { return reinterpret_cast\u0026lt;const char *\u0026gt;(1); } char num_alpha[] = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; int temp = 0; vector\u0026lt;int\u0026gt; number, quotient, result; string s; // 将字母映射为数字  for (char \u0026amp;c : a) { number.push_back(GetValue(c)); } auto iter = number.begin(); while (!number.empty()) { // 得到余数和商  while (iter != number.end()) { temp *= src_base; temp += *iter++; quotient.push_back(temp / to_base); temp %= to_base; } // 得到余数，存入result  result.push_back(temp); // 清空商的前置0  auto i = quotient.begin(); while (*i == 0 \u0026amp;\u0026amp; i != quotient.end()) { i++; } if (i != quotient.begin()) { quotient.erase(quotient.begin(), i); } // 将商作为下一次的运算数，重置商数组和temp  number = quotient; quotient.clear(); iter = number.begin(); temp = 0; } // 逆序余数位  reverse(result.begin(), result.end()); // 将数字映射为字母  for (int \u0026amp;i:result) { s += num_alpha[i]; } return s; } int main() { cout \u0026lt;\u0026lt; BaseConvert(\u0026#34;11110\u0026#34;, 2, 10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; BaseConvert(\u0026#34;30\u0026#34;, 10, 2) \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://leslievan.github.io/2020/03/big-number-base-convert/","summary":"写算法题的时候经常会碰到一些大数相关的问题，比如大数乘法、大数加法等等，乘法和加法的原理基本上都比较符合正常的思维模式，因为加法和乘法的原理","title":"「大数问题」大数任意进制转换"},{"content":"Linux 内核采用了整体结构，上一个实验体会了编译内核时间的冗长与繁杂，一步错就要重新编译，这虽然提高了效率，但同时也让后续的维护变得困难，在这个基础上，Linux 内核引入了动态模块机制加以改进。\n 视频教程地址：\nhttps://www.bilibili.com/video/av47412869/\n源码地址：\nhttps://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab2\n 实验内容  设计一个模块，要求列出系统中所有内核线程的程序名、PID、进程状态、进程优先级、父进程的 PID。 设计一个带参数的模块，其参数为某个进程的 PID 号，模块的功能是列出该进程的家族信息，包括父进程、兄弟进程和子进程的程序名、PID 号及进程状态。 请根据自身情况，进一步阅读分析程序中用到的相关内核函数的源码实现。  代码设计 实验分为两部分，一个让设计出一个不带参数的模块，功能是列出所有内核线程的程序名，称这个模块为 show_all_kernel_thread，另一个要求是设计出一个带参数的模块，参数为某个进程的 PID 号，列出这个进程的父进程、子进程和兄弟进程，称这个模块为 show_task_family。\nshow_all_kernel_thread 可以根据功能写出大致的流程图：\n\n结合代码进行分析：\nshow_all_kernel_thread.c\n#include \u0026#34;linux/init.h\u0026#34;#include \u0026#34;linux/module.h\u0026#34;#include \u0026#34;linux/kernel.h\u0026#34;#include \u0026#34;linux/sched/signal.h\u0026#34;#include \u0026#34;linux/sched.h\u0026#34; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); // 模块在加载的时候会运行init函数 static int __init show_all_kernel_thread_init(void) { // 格式化输出头  struct task_struct *p; printk(\u0026#34;%-20s%-6s%-6s%-6s%-6s\u0026#34;, \u0026#34;Name\u0026#34;, \u0026#34;PID\u0026#34;, \u0026#34;State\u0026#34;, \u0026#34;Prio\u0026#34;, \u0026#34;PPID\u0026#34;); printk(\u0026#34;--------------------------------------------\u0026#34;); // for_each_process(p)的作用是从0开始遍历进程链表中的所有进程  for_each_process(p) { // p最开始指向进程链表中第一个进程，随着循环不断进行p也不断后移直至链表尾  if (p-\u0026gt;mm == NULL) { // 打印进程p的相关信息  printk(\u0026#34;%-20s%-6d%-6d%-6d%-6d\u0026#34;, p-\u0026gt;comm, p-\u0026gt;pid, p-\u0026gt;state, p-\u0026gt;prio, p-\u0026gt;parent-\u0026gt;pid); } } return 0; } // 模块在加载的时候会运行exit函数 static void __exit show_all_kernel_thread_exit(void) { printk(\u0026#34;[ShowAllKernelThread] Module Uninstalled.\u0026#34;); } module_init(show_all_kernel_thread_init); module_exit(show_all_kernel_thread_exit); Makefile\nobj-m := show_all_kernel_thread.o # kernel directory 源码所在文件夹，这里直接指向了系统文件中的内核源码，也可以将该路径改为你下载的源码路径 KDIR := /lib/modules/$(shell uname -r)/build # 当前路径 PWD := $(shell pwd) default: make -C $(KDIR) M=$(PWD) modules clean: make -C $(KDIR) M=$(PWD) clean 这里用到了名为 for_each_process(p) 的宏定义，可以从 include/linux/sched/signal.h 中找到这个宏定义的具体代码：\n#define for_each_process(p) \\ for (p = \u0026amp;init_task ; (p = next_task(p)) != \u0026amp;init_task ; ) 这个宏定义较为简单这里不过多解释，有问题可在评论区一起探讨。\nshow_task_family 同样地，可以根据功能写出大致的流程图：\n\n结合代码进行分析：\nshow_task_family.c\n// created by 19-03-26 // Arcana #include \u0026#34;linux/init.h\u0026#34;#include \u0026#34;linux/module.h\u0026#34;#include \u0026#34;linux/kernel.h\u0026#34;#include \u0026#34;linux/moduleparam.h\u0026#34;#include \u0026#34;linux/pid.h\u0026#34;#include \u0026#34;linux/list.h\u0026#34;#include \u0026#34;linux/sched.h\u0026#34; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); static int pid; module_param(pid, int, 0644); static int __init show_task_family_init(void) { struct pid *ppid; struct task_struct *p; struct task_struct *pos; char *ptype[4] = {\u0026#34;[I]\u0026#34;, \u0026#34;[P]\u0026#34;, \u0026#34;[S]\u0026#34;, \u0026#34;[C]\u0026#34;}; // 通过进程的PID号pid一步步找到进程的进程控制块p  ppid = find_get_pid(pid); if (ppid == NULL) { printk(\u0026#34;[ShowTaskFamily] Error, PID not exists.\\n\u0026#34;); return -1; } p = pid_task(ppid, PIDTYPE_PID); // 格式化输出表头  printk(\u0026#34;%-10s%-20s%-6s%-6s\\n\u0026#34;, \u0026#34;Type\u0026#34;, \u0026#34;Name\u0026#34;, \u0026#34;PID\u0026#34;, \u0026#34;State\u0026#34;); printk(\u0026#34;------------------------------------------\\n\u0026#34;); // Itself  // 打印自身信息  printk(\u0026#34;%-10s%-20s%-6d%-6d\\n\u0026#34;, ptype[0], p-\u0026gt;comm, p-\u0026gt;pid, p-\u0026gt;state); // Parent  // 打印父进程信息  printk(\u0026#34;%-10s%-20s%-6d%-6d\\n\u0026#34;, ptype[1], p-\u0026gt;real_parent-\u0026gt;comm, p-\u0026gt;real_parent-\u0026gt;pid, p-\u0026gt;real_parent-\u0026gt;state); // Siblings  // 遍历父进程的子，即我的兄弟进程，输出信息  // 「我」同样是父进程的子进程，所以当二者进程PID号一致时，跳过不输出  list_for_each_entry(pos, \u0026amp;(p-\u0026gt;real_parent-\u0026gt;children), sibling) { if (pos-\u0026gt;pid == pid) continue; printk(\u0026#34;%-10s%-20s%-6d%-6d\\n\u0026#34;, ptype[2], pos-\u0026gt;comm, pos-\u0026gt;pid, pos-\u0026gt;state); } // Children  // 遍历「我」的子进程，输出信息  list_for_each_entry(pos, \u0026amp;(p-\u0026gt;children), sibling) { printk(\u0026#34;%-10s%-20s%-6d%-6d\\n\u0026#34;, ptype[3], pos-\u0026gt;comm, pos-\u0026gt;pid, pos-\u0026gt;state); } return 0; } static void __exit show_task_family_exit(void) { printk(\u0026#34;[ShowTaskFamily] Module Uninstalled.\\n\u0026#34;); } module_init(show_task_family_init); module_exit(show_task_family_exit); Makefile\n# created by 19-03-26 # Arcana obj-m := show_task_family.o KDIR := /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: make -C $(KDIR) M=$(PWD) modules clean: make -C $(KDIR) M=$(PWD) clean 这个模块中最复杂的部分是 list_for_each_entry。它是位于 include/linux/list.h 中的一个宏定义：\n/* struct task_struct *pos; list_for_each_entry(pos, \u0026amp;pos-\u0026gt;children, sibling); */ #define list_for_each_entry(pos, head, member)\t\\ for (pos = __container_of((head)-\u0026gt;next, pos, member);\t\\ \u0026amp;pos-\u0026gt;member != (head);\t\\ pos = __container_of(pos-\u0026gt;member.next, pos, member)) 可以看到，展开之后它是一个清晰的 for 循环，三个参数分别是 pos、head 和 member，关于这个宏定义建议大家仔细阅读书本 7.3.4。这是一个非常奇妙的操作，基于此它可以将任意一个结构体都附上链表的功能，只需要将一个叫做 list_head 的数据结构放在结构体中，这一部分理解起来可能稍微复杂，这里只讲解用法，有兴趣的同学可以自行研究。\npos 是数据项类型的指针，比如这里需要使用 task_struct 类型的数据，所以在上面的示例中，将 pos 声明为 task_struct * 类型.\n剩下两个参数结合下图理解：\n\n这里的 *.children 和 *.sibling 均为 list_head * 类型的变量，是 task_struct 的一个成员，在这里，parent.children.next 指向的是 children1.sibling，而 children4.sibling.next 指向的是 parent.children，它是一个双向循环链表，这里只标注出了 next 的一侧，隐去了 prev 的一侧。\n第二个参数 head 是表头的地址，在这里就表示为 \u0026amp;parent.children，第三个参数 member 指的是在链表中，list_head * 的位置，可能会混淆的是，task_struct 中的两个成员变量 children 和 sibling 都是 list_head * 类型，为什么选择 sibling 而不是 children 呢？我个人的理解是，children 只是一个引子，代表一个参照物，真正进行中转的变量是 sibling，才疏学浅，表达不太准确，有兴趣的同学可以自行查阅资料。\n编译 \u0026amp; 安装 模块编译的命令与第一个实验中内核编译的命令是一致的，实际上 make 命令能做的远不止编译内核和编译模块。\n上面一共四个文件，分为两个文件夹储存，这里将文件夹命名为 A 和 B，把 show_all_kernel_thread.c 和与之对应的 Makefile 文件放到 A 中，自然地，把 show_task_family.c 和与之对应的 Makefile 文件放到 B 中。\n# 将A改为当前目录，开始编译 cd A make 编译成功之后你的 A 目录下应该有这些文件，同理你可以在 B 目录下进行同样的操作：\n. ├── Makefile ├── modules.order ├── Module.symvers ├── show_all_kernel_thread.c ├── show_all_kernel_thread.ko ├── show_all_kernel_thread.mod.c ├── show_all_kernel_thread.mod.o └── show_all_kernel_thread.o 检验文件后，开始安装模块\n# 安装 # without parameter sudo insmod show_all_kernel_thread.ko # with parameter sudo insmod show_task_family pid=xxxx # 卸载（在整个文件结束之后 sudo rmmod show_all_kernel_thread sudo rmmod show_task_family 测试 前文提到，当模块被加载时，会运行 init 函数，在退出时，会运行 exit 函数。printk 函数将输出打印到了日志中，可以使用 dmesg 命令查看系统日志，如果有遗留下的痕迹，且是正确答案，则代表测试成功。\nshow_all_kernel_thread 要求显示出所有内核线程，测试步骤可如下：\nmake \u0026amp;\u0026amp; sudo insmod show_all_kernel_thread.ko dmesg 开启另一个终端，输入 ps 命令：\nps -aux 此时会显示出所有线程，线程名带有 [] 的即为内核线程，稍微挑选一二能对上即可。\n show_task_family 要求显示出某一个进程的家族关系，测试步骤可如下：\n使用 pstree 命令查看进程树：\npstree -p 选择一个既有兄弟进程又有子进程的进程（建议使用 systemd，使用此进程作为测试，可以看到这个进程的 PID。\nmake \u0026amp;\u0026amp; sudo insmod show_task_family.ko pid=xxxx dmesg 开启另一个终端，输入 pstree 命令：\npstree -p xxxx xxxx 是刚刚选中的那个进程号。\n对比进程树与系统日志中的记录，选择一二能对上即可。\n相关阅读  【OS】HDU-OS-Lab1-Linux 内核编译及添加系统调用 【OS】HDU-OS-Lab3-Linux 进程管理（二）管道通信 【OS】HDU-OS-Lab3-Linux 进程管理（三）进程通信  ","permalink":"https://leslievan.github.io/2019/03/os-lab2/","summary":"Linux 内核采用了整体结构，上一个实验体会了编译内核时间的冗长与繁杂，一步错就要重新编译，这虽然提高了效率，但同时也让后续的维护变得困难，在这个基","title":"「OS」HDU-OS-Lab2-Linux 内核模块编程"},{"content":"添加一个系统调用，实现对指定进程的 nice 值的修改或读取功能，并返回进程最新的 nice 值及优先级 prio。\n 视频教程地址：\nhttps://www.bilibili.com/video/av47274857\n源码地址：\nhttps://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab1\n 以下内容全部在 Ubuntu 18.04 下操作，使用其他发行版的同学可在此基础上自行修改。\n实验内容  添加一个系统调用，实现对指定进程的 nice 值的修改或读取功能，并返回进程最新的 nice 值及优先级 prio。 写一个简单的应用程序测试添加的系统调用。 若程序中调用了 Linux 的内核函数，要求深入阅读相关函数源码。  准备工作 安装 Linux 虚拟机  为免于重装系统，建议你使用 VMware 创建一个 Linux 虚拟机，在虚拟机下进行内核编译与安装，坏处是虚拟机的性能远不如主机，使得编译时长可能翻倍，好处是不管你怎么折腾，都不会弄坏自己的主机系统。\n  安装 VMware，请查看这篇文章：Ubuntu 下配置 VMware Workstation 安装虚拟机，请查看这篇文章：在 VMware Workstation 中创建虚拟机  获取内核源码 从 The Linux Kernel Archives 获取 Linux 的内核源码，任意选择一个版本，建议使用 longterm 版本。\n戳这里下载 linux-4.19.113.tar.xz。\n解压内核源码 可以通过命令行或图形界面进行解压：\n  右键单击内核压缩包，点击解压\n  或在终端键入如下命令检查文件是否存在。（系统语言为中文的请将 Downloads 替换为下载）。\ncd ~/Downloads tar xvJf linux-4.19.25.tar.xz tar 命令参数解释参见附录 1-tar.\n  修改内核 修改系统调用表 根据上一步内核源码解压目录，定位系统调用表：\n# 将~/Downloads/linux-4.19.113替换为你的内核源码解压目录 gedit ~/Downloads/linux-4.19.113/arch/x86/entry/syscalls/syscall_64.tbl 可以看到格式为：\u0026quot;number\u0026quot; \u0026quot;abi\u0026quot; \u0026quot;name\u0026quot; \u0026quot;entry point\u0026quot;。\n定位到 common/64 的最后一条：\n在下面添加：\n335\t64\tmysetnice\t__x64_sys_mysetnice 申明系统调用服务例程原型 根据内核源码解压目录，定位系统调用头文件：\n# 将~/Downloads/linux-4.19.113替换为你的内核源码解压目录 gedit ~/Downloads/linux-4.19.113/include/linux/syscalls.h 定位到最后一行：\n在 endif 前面添加系统调用原型声明：\nasmlinkage long sys_mysetnice(pid_t pid, int flag, int nicevaluse, void __user* prio, v 实现系统调用服务例程 这一步与上一步的关系，就是 C 语言中头文件与实现文件的关系，上一步对函数进行了声明，这里给函数一个具体的实现。\n 需要实现的任务为：\n添加一个系统调用，对指定进程的 nice 值的修改及读取的功能，同时返回进程最新的 nice 值及优先级 prio。\n分解为四步：\n 根据进程号 pid 找到相应的进程控制块 PCB（因为进程控制块中记录了用于描述进程情况及控制进程运行所需要的全部信息，nice 值和优先级正是其中的一部分）； 根据 PCB 读取它的 nice 值和优先级 prio； 根据 PCB 对相应进程的 nice 值进行修改； 将得到的 nice 值和优先级 prio 进行返回。   根据内核源码解压目录，定位系统调用头文件：\n# 将~/Downloads/linux-4.19.113替换为你的内核源码解压目录 gedit ~/Downloads/linux-4.19.113/include/linux/syscalls.h 定位到最后一行：\n在 endif 前面添加系统调用服务例程实现代码：\n// 置于sys.c的最末端（在‘#endif’之前 SYSCALL_DEFINE5(mysetnice, pid_t, pid, int, flag, int, nicevalue, void __user *, prio, void __user *, nice) { int cur_prio, cur_nice; struct pid *ppid; struct task_struct *pcb; // 通过进程PID号找到进程的PID结构体，如果ppid为空指针则代表不存在与进程号与pid相同的进程，此时返回EFAULT（  // 我编译的时候这个if判断并没有加进去，想做出上述判断的可以将注释删去，就逻辑本身而言没有问题-_-  // 但我无法保证最后是否会出问题，因为我没有自己尝试过  ppid = find_get_pid(pid); /* if (ppid == NULL) return EFAULT; */ // 通过进程的PID结构体，找到与之对应的进程控制块  pcb = pid_task(ppid, PIDTYPE_PID); // 如果flag=1则修改进程的nice值为nicevalue  if (flag == 1) { set_user_nice(pcb, nicevalue); } // flag既不为1也不为0的时候，即flag出错，此时返回EFAULT  else if (flag != 0) { return EFAULT; } // 获取进程当前的最新nice值和prio值  cur_prio = task_prio(pcb); cur_nice = task_nice(pcb); // 由于系统调用是在内核态下运行的，所有数据均为内核空间的数据，  // 利用copy_to_user()函数将内核空间的数据复制到用户空间  copy_to_user(prio, \u0026amp;cur_prio, sizeof(cur_prio)); copy_to_user(nice, \u0026amp;cur_nice, sizeof(cur_nice)); return 0; } 需要用到的几个内核函数：\n struct pid *find_get_pid(pid_t nr)：根据进程标识符号返回相应的进程标识符 struct task_struct *pid_task(struct pid *pid, enum pid_type type)：根据进程标识符和进程类型返回进程控制块 int task_prio(const struct task_struct *p)：返回该 PCB 的 prio 参数 static inline int task_nice(const struct task_struct *p)：返回该 PCB 的 nice 参数 void set_user_nice(struct task_struct *p, long nice)：修改 PCB 的 nice 参数 static __always_inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n)：将变量从内核空间复制到用户空间  内核函数具体实现见附录 2\n编译内核 修改好内核后，开始进行编译。\n安装依赖 以下是一些需要用到的包，用 apt/apt-get 进行安装，命令行输入：\nsudo apt-get install libncurses5-dev make openssl libssl-dev bison flex libelf-dev 参数确认 定位内核源码解压目录，命令行运行：\n# 将~/Downloads/linux-4.19.113替换为你的内核源码解压目录 cd ~/Downloads/linux-4.19.113 命令行运行 make，开始编译前的参数确认：\nmake menuconfig 出现如下所示界面后，左右键移动下方光标选中 Save，按 Enter 结束。\n点击 Ok 和之后出现的 Exit。\n左右键移动光标，选中 Exit，Enter 键结束这一步。\n编译 编译内核需要耗费的时间较长，建议通电进行。\n定位内核源码解压目录，命令行运行：\nsudo make -j4 2\u0026gt; error.log -j4 表示使用四线程进行编译，这个过程大概持续一个小时，后面的重定向将错误信息输出到了 error.log 这个文件里面，方便之后进行错误排查。\n make 命令默认是指编译所有，包括内核和模块，所以不需要再重新使用 make modules 进行模块的编译（至少我并没有在这个地方受到困扰）。\n如果碰到问题请查阅附录 3。\n 安装内核 等待内核、模块均编译完成，开始安装内核，分为两步：\n  安装模块\n# 大约持续十几分钟到几十分钟不等 sudo make modules_install   替换内核\n# 大约持续几分钟到十几分钟不等 sudo make install   替换完成后重启你的电脑，准备下一步的测试，如果电脑打不开可以参考附录 3。\n测试 完成编译工作后，需要编写一个用户态程序，测试系统调用是否正常工作，这里直接给出 demo.c，请自行查阅理解。\ndemo.clink // demo.c #include \u0026#34;unistd.h\u0026#34;#include \u0026#34;sys/syscall.h\u0026#34;#include \u0026#34;stdio.h\u0026#34;#define _SYSCALL_MYSETNICE_ 335 #define EFALUT 14  int main() { int pid, flag, nicevalue; int prev_prio, prev_nice, cur_prio, cur_nice; int result; printf(\u0026#34;Please input variable(pid, flag, nicevalue): \u0026#34;); scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;pid, \u0026amp;flag, \u0026amp;nicevalue); result = syscall(_SYSCALL_MYSETNICE_, pid, 0, nicevalue, \u0026amp;prev_prio, \u0026amp;prev_nice); if (result == EFALUT) { printf(\u0026#34;ERROR!\u0026#34;); return 1; } if (flag == 1) { syscall(_SYSCALL_MYSETNICE_, pid, 1, nicevalue, \u0026amp;cur_prio, \u0026amp;cur_nice); printf(\u0026#34;Original priority is: [%d], original nice is [%d]\\n\u0026#34;, prev_prio, prev_nice); printf(\u0026#34;Current priority is : [%d], current nice is [%d]\\n\u0026#34;, cur_prio, cur_nice); } else if (flag == 0) { printf(\u0026#34;Current priority is : [%d], current nice is [%d]\\n\u0026#34;, prev_prio, prev_nice); } return 0; } 命令行使用 gcc 进行编译，根据提示信息输入 pid、flag 和 nicevalue 进行测试。\n# 将~/demo.c替换为你的demo.c所在位置 gcc ~/demo.c -o demo ./demo 附录 附录 1：tar tar xvJf linux-4.19.133.tar.bz tar 命令可以为 linux 的文件和目录创建档案，利用 tar 可以把一大堆的文件和目录全部打包成一个文件。\n -x 或–extract 或–get：从备份文件中还原文件，即解压 -v：显示操作过程，即显示进度 -j：支持 bzip2 解压文件，即解压 tar.bz 文件 -f \u0026lt;备份文件\u0026gt; 或–file=\u0026lt; 备份文件 \u0026gt;：指定备份文件，即解压对应路径的文件  附录 2：内核函数 find_get_pid() struct pid *find_get_pid(pid_t nr) { struct pid *pid; rcu_read_lock(); pid = get_pid(find_vpid(nr)); rcu_read_unlock(); return pid; } pid_task() struct task_struct *pid_task(struct pid *pid, enum pid_type type) { struct task_struct *result = NULL; if (pid) { struct hlist_node *first; first = rcu_dereference_check(hlist_first_rcu(\u0026amp;pid-\u0026gt;tasks[type]), lockdep_tasklist_lock_is_held()); if (first) result = hlist_entry(first, struct task_struct, pid_links[(type)]); } return result; } task_prio() int task_prio(const struct task_struct *p) { return p-\u0026gt;prio - MAX_RT_PRIO; } task_nice() static inline int task_nice(const struct task_struct *p) { return PRIO_TO_NICE((p)-\u0026gt;static_prio); } set_user_nice() void set_user_nice(struct task_struct *p, long nice) { bool queued, running; int old_prio, delta; struct rq_flags rf; struct rq *rq; if (task_nice(p) == nice || nice \u0026lt; MIN_NICE || nice \u0026gt; MAX_NICE) return; /* * We have to be careful, if called from sys_setpriority(), * the task might be in the middle of scheduling on another CPU. */ rq = task_rq_lock(p, \u0026amp;rf); update_rq_clock(rq); /* * The RT priorities are set via sched_setscheduler(), but we still * allow the \u0026#39;normal\u0026#39; nice value to be set - but as expected * it wont have any effect on scheduling until the task is * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: */ if (task_has_dl_policy(p) || task_has_rt_policy(p)) { p-\u0026gt;static_prio = NICE_TO_PRIO(nice); goto out_unlock; } queued = task_on_rq_queued(p); running = task_current(rq, p); if (queued) dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK); if (running) put_prev_task(rq, p); p-\u0026gt;static_prio = NICE_TO_PRIO(nice); set_load_weight(p, true); old_prio = p-\u0026gt;prio; p-\u0026gt;prio = effective_prio(p); delta = p-\u0026gt;prio - old_prio; if (queued) { enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK); /* * If the task increased its priority or is running and * lowered its priority, then reschedule its CPU: */ if (delta \u0026lt; 0 || (delta \u0026gt; 0 \u0026amp;\u0026amp; task_running(rq, p))) resched_curr(rq); } if (running) set_curr_task(rq, p); out_unlock: task_rq_unlock(rq, p, \u0026amp;rf); } copy_to_user() static __always_inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n) { if (likely(check_copy_size(from, n, true))) n = _copy_to_user(to, from, n); return n; } 附录 3：Q\u0026amp;A  每次出现错误后都需要执行 sudo make clean 清除残余文件！ 每次出现错误后都需要执行 sudo make clean 清除残余文件！ 每次出现错误后都需要执行 sudo make clean 清除残余文件！\n Q1：在完成所有步骤重启系统时，提示：Kernel panic - not syncing: System is deadlocked on memory\nA1：原因是只给虚拟机分配了 2G 的内存，导致了系统在内存上的死锁，将虚拟机内存扩充至 4G 后解决。\nQ2：编译时提示 gcc: error: unrecognized command line option '-fno-plt'，如下所示：\nHOSTCC scripts/selinux/genheaders/genheaders HOSTCC scripts/selinux/mdp/mdp gcc: error: unrecognized command line option ‘-fno-plt’ gcc: error: unrecognized command line option ‘-fno-plt’ HOSTCC /root/linux52/linux-5.2.13/tools/objtool/fixdep.o HOSTLD /root/linux52/linux-5.2.13/tools/objtool/fixdep-in.o LINK /root/linux52/linux-5.2.13/tools/objtool/fixdep CC /root/linux52/linux-5.2.13/tools/objtool/arch/x86/decode.o gcc: error: unrecognized command line option ‘-fno-plt’ A2：原因是gcc版本过低，-fno-plt标志是gcc6才提出的，可以用命令gcc \u0026ndash;version查看自己的版本。可以先尝试使用sudo apt-get install gcc6，但在部分系统中，并未收录gcc6，如果直接安装的方法无效，显示无法定位软件包的话，可以采用手动添加PPA的方法：\ncurl https://gist.githubusercontent.com/leslievan/3c2872d7b375c22a2df60c57dbf7bd27/raw/8ef3b032797b03dec824707ad6294aa43301ab8d/ubuntu-install-gcc-6 | bash Q3：编译时提示 /bin/sh: 1: bc: not found，如下所示：\nCALL scripts/atomic/check-atomics.sh /bin/sh: 1: bc: not found Kbuild:26: recipe for target \u0026#39;include/generated/timeconst.h\u0026#39; failed make[1]: *** [include/generated/timeconst.h] Error 127 make[1]: *** 正在等待未完成的任务.... A3：原因是没有安装 bc，执行 sudo apt-get install bc 将它安装上即可，出现类似的 xxx: not found 的错误都可以尝试使用 sudo apt-get install xxx 安装后再次尝试。\n相关阅读  【OS】HDU-OS-Lab2-Linux 内核模块编程 【OS】HDU-OS-Lab3-Linux 进程管理（二）管道通信 【OS】HDU-OS-Lab3-Linux 进程管理（三）进程通信  ","permalink":"https://leslievan.github.io/2019/01/os-lab1/","summary":"添加一个系统调用，实现对指定进程的 nice 值的修改或读取功能，并返回进程最新的 nice 值及优先级 prio。 视频教程地址： https://www.bilibili.com/video/av47274857 源码地址： https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab1 以下内容全部在 Ubuntu 18.04","title":"「OS」HDU-OS-Lab1-Linux 内核编译及添加系统调用"}]