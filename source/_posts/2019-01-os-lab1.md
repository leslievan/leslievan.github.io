---
title: "【OS】HDU-OS-Lab1-Linux内核编译及添加系统调用"
date: 2019-01-29 23:08:16
categories: "Note"
tags: 
    - "OS"
    - "Lab"
    - "HDU"
---

添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级prio。

> 视频教程地址：
>
> <https://www.bilibili.com/video/av47274857>
>
> 源码地址：
>
> <https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab1>

<!--more-->


需要提前说明的是，以下内容全部在`Ubuntu 18.04`下操作，在其他发行版上操作的同学可在此基础上自行修改。

全程视频已录制，可在每小节末尾看到相关链接。

## 实验内容

- 添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级prio。
- 写一个简单的应用程序测试添加的系统调用。
- 若程序中调用了Linux的内核函数，要求深入阅读相关函数源码。

## 准备工作

**安装Linux虚拟机**

> 如果使用Linux作为自己的主系统的同学，请略过这一步。

首先，你需要有一个Linux内核的系统，为免于重装系统，建议你使用VMware创建一个Linux虚拟机，在虚拟机下进行内核编译与安装，坏处是虚拟机的性能远不如主机，使得**编译时长可能翻倍**，好处是不管你怎么折腾，都**不会弄坏自己的主机系统**。

- 安装VMware，请查看这篇文章：[Ubuntu下配置VMware Workstation](/2019/02/ubuntu-config-vmware/)

- 安装虚拟机，请查看这篇文章：[在VMware Workstation中创建虚拟机](/2019/03/vmware-create-vm/)

**了解相关内容**

其次，你应该阅读书本`7.2.2 Linux系统调用的基本概念`，验收实验的时候，老师理论部分大概率会问与这一节相关的问题，如果你想有一个足够高的分数，请认真阅读这一部分。

**获取内核源码**

然后，你需要准备Linux的内核源码，可以从[The Linux Kernel Archives](https://www.kernel.org)获取，任意选择一个版本。

---

至此，准备工作结束，你有了一个Linux（Ubuntu）虚拟机，一部分内核编译的知识，和一个`linux-4.19.25.tar.xz`的内核源码文件。

在编译开始之前，请再检查一遍你的`文件-下载`中，已有`linux-4.19.25.tar.xz`的内核源码文件，如下图所示：

![](https://leslie-cloud.oss-cn-beijing.aliyuncs.com/2019/02/2019-01-29-62088c7-1.png)

或在终端键入如下命令检查文件是否存在。（系统语言为中文的请将`Downloads`替换为`下载`。

```bash
$ cd ~/Downloads
$ ls
linux-4.19.25.tar.xz
```

**切换超级用户**

书本建议全程使用`root`用户进行操作，好处是不必在每一步操作时都使用`sudo`增加操作权限，切换用户的方法如下：

```bash
$ sudo passwd root
[sudo] password for leslie: 
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
$ su root
Password:
```

解释一下这些代码。

1. 首先，你安装Linux系统时，它会让你设置一个你的用户名和用户密码，在这里我设置的用户名是`leslie`，即绿色字体`leslie@tp50`的前半部分，后半部分`tp50`是我的主机名。
2. `sudo`放在命令首，意思是当前指令以管理员权限运行。
3. `passwd`是一条命令，用来修改用户密码，参数`root`是超级用户名，拥有系统最高的权限。`passwd root`的意思是修改超级用户的密码，在创建Ubuntu时，默认超级用户是没有密码的（也可能是一个随机数之类的我不记得了），用这条命令重新设定一个密码。
4. `su`是一条命令，用来切换当前用户，在第一章你会认识到，Linux是一个多用户多任务的操作系统。参数`root`是用户名，指示切换到的用户，在这里`su root`意为切换到`root`用户，当参数缺省时，默认切换到超级用户。
5. 你会发现，它在提示输入密码时，虽然键盘已经输入了密码，但是终端没有任何响应，不要担心，这正是Unix和Linux的特点，为了确保安全，在输入密码时不显示输入的内容，**在输入密码后，直接按下回车就好了**。

**解压缩内核源码**

切换到内核源码所在目录，然后解压缩压缩包至文件夹`/usr/src`，此处存储内核源码。

```bash
cd ~/Downloads
tar xvJf linux-4.19.25.tar.xz -C /usr/src
```

## 修改内核

修改内核包括但不限于添加系统调用，书中为了让初学者不至于混淆，将添加系统调用与内核编译的步骤分开了。这一部分直接使用了书上的内容，自学能力强的同学可以跳过这一部分，直接看书亦可。

**分配系统调用号，修改系统调用表**

查看系统调用表，并添加新的系统调用号。

```bash
gedit /usr/src/linux-4.19.25/arch/x86/entry/syscalls/syscall_64.tbl
```

可以看到格式为：`&lt;number &gt; &lt;abi&gt; &lt;name&gt; &lt;entry point&gt;`。

| 名称            | 作用             |
| --------------- | ---------------- |
| number      | 系统调用号       |
| abi         | 应用二进制接口   |
| name;        | 系统调用名       |
| entry point | 服务例程入口地址 |

应用二进制接口分为三种：`64`、`x32`和`common`，即三种不同的调用约定，这里不需考虑太多，三种任意选择一种即可，按照上述格式编写新的系统调用表表项如下：

```text syscall_64.tbl
335	64	mysetnice		__x64_sys_mysetnice
```

分配后系统调用表如下：

**申明系统调用服务例程原型**

查看系统调用头文件：

```bash
gedit /usr/src/linux-4.19.25/include/linux/syscalls.h
```

在最后面加上我们的系统调用原型声明：

```bash
asmlinkage long sys_mysetnice(pid_t pid, int flag, int nicevaluse, void __user* prio, void __user* nice);
```

修改之后如下：

**实现系统调用服务例程**

这一步与上一步的关系，就是C语言中头文件与实现文件的关系，上一步我们对函数进行了声明，这里给函数一个具体的实现。

首先要明确，我们要实现一个什么样的功能，根据内容要求可知，这个系统调用需要具备对指定进程的nice值的修改及读取的功能，同时返回进程最新的nice值及优先级prio。

把功能分拆成一个一个小块，我们需要做到的有以下几点：

1. 根据进程号pid找到相应的进程控制块PCB（因为进程控制块中记录了**用于描述进程情况及控制进程运行所需要的全部信息**，nice值和优先级正是其中的一部分）；
2. 根据PCB读取它的nice值和优先级prio；
3. 根据PCB对相应进程的nice值进行修改；
4. 将得到的nice值和优先级prio进行返回。

这里提供几个内核函数的源码：

> 源码可以帮助理解整个实验，可在实验完毕之后再回头看这一部分。

{% tabs source_code %}

<!-- tab find_get_pid -->
```c
struct pid *find_get_pid(pid_t nr)
{
	struct pid *pid;

	rcu_read_lock();
	pid = get_pid(find_vpid(nr));
	rcu_read_unlock();

	return pid;
}
```
<!-- endtab -->

<!-- tab pid_task -->
```c
struct task_struct *pid_task(struct pid *pid, enum pid_type type)
{
	struct task_struct *result = NULL;
	if (pid) {
		struct hlist_node *first;
		first = rcu_dereference_check(hlist_first_rcu(&pid->tasks[type]),
					      lockdep_tasklist_lock_is_held());
		if (first)
			result = hlist_entry(first, struct task_struct, pid_links[(type)]);
	}
	return result;
}
```
<!-- endtab -->

<!-- tab task_prio -->
```c
int task_prio(const struct task_struct *p)
{
	return p->prio - MAX_RT_PRIO;
}
```
<!-- endtab -->

<!--tab task_nice -->
```c
static inline int task_nice(const struct task_struct *p)
{
	return PRIO_TO_NICE((p)->static_prio);
}
```
<!-- endtab -->

<!-- tab set_user_nice -->
```c
void set_user_nice(struct task_struct *p, long nice)
{
	bool queued, running;
	int old_prio, delta;
	struct rq_flags rf;
	struct rq *rq;

	if (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)
		return;
	/*
	 * We have to be careful, if called from sys_setpriority(),
	 * the task might be in the middle of scheduling on another CPU.
	 */
	rq = task_rq_lock(p, &rf);
	update_rq_clock(rq);

	/*
	 * The RT priorities are set via sched_setscheduler(), but we still
	 * allow the 'normal' nice value to be set - but as expected
	 * it wont have any effect on scheduling until the task is
	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:
	 */
	if (task_has_dl_policy(p) || task_has_rt_policy(p)) {
		p->static_prio = NICE_TO_PRIO(nice);
		goto out_unlock;
	}
	queued = task_on_rq_queued(p);
	running = task_current(rq, p);
	if (queued)
		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);
	if (running)
		put_prev_task(rq, p);

	p->static_prio = NICE_TO_PRIO(nice);
	set_load_weight(p, true);
	old_prio = p->prio;
	p->prio = effective_prio(p);
	delta = p->prio - old_prio;

	if (queued) {
		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);
		/*
		 * If the task increased its priority or is running and
		 * lowered its priority, then reschedule its CPU:
		 */
		if (delta < 0 || (delta > 0 && task_running(rq, p)))
			resched_curr(rq);
	}
	if (running)
		set_curr_task(rq, p);
out_unlock:
	task_rq_unlock(rq, p, &rf);
}
```
<!-- endtab -->

<!-- tab copy_to_user -->
```c
static __always_inline unsigned long __must_check
copy_to_user(void __user *to, const void *from, unsigned long n)
{
	if (likely(check_copy_size(from, n, true)))
		n = _copy_to_user(to, from, n);
	return n;
}```
<!-- endtab -->

{% endtabs %}


我们沿着如下图所示的脉络设计系统调用函数：

![](https://leslie-cloud.oss-cn-beijing.aliyuncs.com/2019/03/2019-01-29-62088c7-3.svg)

配合代码来说明这个流程图：

```c sys.c
// 置于sys.c的最末端（在‘#endif’之前
SYSCALL_DEFINE5(mysetnice, pid_t, pid, int, flag, int, nicevalue, void __user *,
                prio, void __user *, nice) {
    int cur_prio, cur_nice;
    struct pid *ppid;
    struct task_struct *pcb;

    // 通过进程PID号找到进程的PID结构体，如果ppid为空指针则代表不存在与进程号与pid相同的进程，此时返回EFAULT（
    // 我编译的时候这个if判断并没有加进去，想做出上述判断的可以将注释删去，就逻辑本身而言没有问题-_-
    // 但我无法保证最后是否会出问题，因为我没有自己尝试过
    ppid = find_get_pid(pid);
    /*
    if (ppid == NULL)
        return EFAULT;
    */

    // 通过进程的PID结构体，找到与之对应的进程控制块
    pcb = pid_task(ppid, PIDTYPE_PID);

    // 如果flag=1则修改进程的nice值为nicevalue
    if (flag == 1) {
        set_user_nice(pcb, nicevalue);
    }  // flag既不为1也不为0的时候，即flag出错，此时返回EFAULT
    else if (flag != 0) {
        return EFAULT;
    }

    // 获取进程当前的最新nice值和prio值
    cur_prio = task_prio(pcb);
    cur_nice = task_nice(pcb);

    // 由于系统调用是在内核态下运行的，所有数据均为内核空间的数据，
    // 利用copy_to_user()函数将内核空间的数据复制到用户空间
    copy_to_user(prio, &cur_prio, sizeof(cur_prio));
    copy_to_user(nice, &cur_nice, sizeof(cur_nice));

    return 0;
}
```

将更改保存，退出`Vim`。

**Bilibili: <https://www.bilibili.com/video/av47274857/?p=1>** 


<iframe width="100%" height=500 src="//player.bilibili.com/player.html?aid=47274857&cid=82790619&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

## 编译内核

**准备好所需要的包**

首先将所需要的包（软件）都安装好，不管有没有安装的都可以使用这条代码进行查漏补缺：

```bash
sudo apt-get install libncurses5-dev make openssl libssl-dev bison flex libelf-dev
```

然后将当前目录定位到源代码所在文件夹：

```bash
cd /xx/xx/linux-x.xx.xx
```

运行命令：

```bash
make menuconfig
```

出现如下所示界面后，左右键移动下方光标选中`Save`，按`Enter`结束。

![](https://leslie-cloud.oss-cn-beijing.aliyuncs.com/2019/03/2019-01-29-62088c7-4.png)

![](https://leslie-cloud.oss-cn-beijing.aliyuncs.com/2019/03/2019-01-29-62088c7-5.png)

点击`Ok`和之后出现的`Exit`。

![](https://leslie-cloud.oss-cn-beijing.aliyuncs.com/2019/03/2019-01-29-62088c7-6.png)

![](https://leslie-cloud.oss-cn-beijing.aliyuncs.com/2019/03/2019-01-29-62088c7-7.png)

左右键移动光标，选中`Exit`，`Enter`键结束这一步。

![](https://leslie-cloud.oss-cn-beijing.aliyuncs.com/2019/03/2019-01-29-62088c7-8.png)

---

**编译**

编译内核需要耗费的时间较长，建议通电进行。

```bash
sudo make -j4 2> error.log 
```

`-j4`表示使用四线程进行编译，这个过程大概持续一个小时，后面的重定向将错误信息输出到了`error.log`这个文件里面，方便我们之后进行错误排查，不至于一两个小时坐在电脑面前盯着信息输出生怕出现一个错误而自己错过了，之后修改只能靠两眼排查，并非什么好的体验。

{% note primary %}
<code>make</code>命令默认是指编译所有，包括内核和模块，所以不需要再重新使用<code>make modules</code>进行模块的编译（至少我并没有在这个地方受到困扰）。
如果碰到问题请查阅最后一节<a href="#q-a">Q&A</a>
{% endnote %}

**Bilibili**: https://www.bilibili.com/video/av47274857/?p=2

<iframe width="100%" height=500 src="//player.bilibili.com/player.html?aid=47274857&cid=82790619&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

## 安装内核

一两个小时后（如果你是双系统而不是虚拟机，这个过程会适当缩短一些），待内核和模块均编译完成，我们就可以愉快地开始安装了，安装顺序是`安装模块->替换内核`。

**安装模块**

```bash
sudo make modules_install
```

使用这一行命令进行模块的安装，模块的安装持续时间大概在十几分钟左右，视你分配的资源多寡这个时间会适当地增加或减少。

**替换内核**

```bash
sudo make install
```

使用这一行命令进行内核的安装，内核的安装持续时间大概是几分钟，视你分配的资源多寡这个时间会适当地增加或减少。

这一步完成且没有任何错误后，恭喜你，你已经完成了绝大多数的工作了，剩下的都是一些简单且容易调试的内容，重启你的电脑/虚拟机。

> 安装的视频不知道为什么没办法录制，但只有两个步骤，非常简单，如果有问题的话请在下面留言即可。

## 测试

完成内核编译后，我们需要测试这个系统调用是否好用，写一个用户态程序来进行测试。这里我直接将测试代码贴上来，比较容易就不做讲解了。

```c demo.c
// Created by 202019/03-25
// Arcana
#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;stdio.h&gt;
#define _SYSCALL_MYSETNICE_ 335
#define EFALUT 14

int main()
{
    int pid, flag, nicevalue;
    int prev_prio, prev_nice, cur_prio, cur_nice;
    int result;

    printf("Please input variable(pid, flag, nicevalue): ");
    scanf("%d%d%d", &pid, &flag, &nicevalue);

    result = syscall(_SYSCALL_MYSETNICE_, pid, 0, nicevalue, &prev_prio,
                     &prev_nice);
    if (result == EFALUT)
    {
        printf("ERROR!");
        return 1;
    }

    if (flag == 1)
    {
        syscall(_SYSCALL_MYSETNICE_, pid, 1, nicevalue, &cur_prio, &cur_nice);
        printf("Original priority is: [%d], original nice is [%d]\n", prev_prio,
               prev_nice);
        printf("Current priority is : [%d], current nice is [%d]\n", cur_prio,
               cur_nice);
    }
    else if (flag == 0)
    {
        printf("Current priority is : [%d], current nice is [%d]\n", prev_prio,
               prev_nice);
    }

    return 0;
}
```

使用`gcc`进行编译，根据提示信息输入`pid`、`flag`和`nicevalue`进行测试。

**Bilibili: https://www.bilibili.com/video/av47274857/?p=3**

<iframe width="100%" height=500 src="//player.bilibili.com/player.html?aid=47274857&cid=82790619&page=3" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

## Q & A

{% note primary %}
每次出现错误后都需要执行<code>sudo make clean</code>清除残余文件！</br>
每次出现错误后都需要执行<code>sudo make clean</code>清除残余文件！</br>
每次出现错误后都需要执行<code>sudo make clean</code>清除残余文件！</br>
{% endnote %}



{% note primary %}
<p>
Q：在完成所有步骤重启系统时，提示：<code>Kernel panic - not syncing: System is deadlocked on memory</code>
</p>
<p>
<img src="https://leslie-cloud.oss-cn-beijing.aliyuncs.com/2019/03/2019-01-29-62088c7-2.png" alt="ERROR1">
</p>
A：原因是只给虚拟机分配了2G的内存，导致了系统在内存上的死锁，<strong>将虚拟机内存扩充至4G</strong>后解决。
{% endnote %}

---

{% note primary %}
Q：编译时提示`gcc: error: unrecognized command line option '-fno-plt'`，如下所示：

```bash
  HOSTCC  scripts/selinux/genheaders/genheaders
  HOSTCC  scripts/selinux/mdp/mdp
gcc: error: unrecognized command line option ‘-fno-plt’
gcc: error: unrecognized command line option ‘-fno-plt’
  HOSTCC   /root/linux52/linux-5.2.13/tools/objtool/fixdep.o
  HOSTLD   /root/linux52/linux-5.2.13/tools/objtool/fixdep-in.o
  LINK     /root/linux52/linux-5.2.13/tools/objtool/fixdep
  CC       /root/linux52/linux-5.2.13/tools/objtool/arch/x86/decode.o
gcc: error: unrecognized command line option ‘-fno-plt’
```

A：原因是<code>gcc</code>版本过低，<code>-fno-plt</code>标志是<code>gcc6</code>才提出的，可以用命令<code>gcc --version</code>查看自己的版本。可以先尝试使用<code>sudo apt-get install gcc6</code>，但在部分系统中，并未收录<code>gcc6</code>，如果直接安装的方法无效，显示无法定位软件包的话，可以采用手动添加PPA的方法：
```bash
$ curl https://gist.githubusercontent.com/leslievan/3c2872d7b375c22a2df60c57dbf7bd27/raw/8ef3b032797b03dec824707ad6294aa43301ab8d/ubuntu-install-gcc-6 | bash
```
{% endnote %}

---

{% note primary %}
Q：编译时提示<code>/bin/sh: 1: bc: not found</code>，如下所示：

```bash
 CALL    scripts/atomic/check-atomics.sh
/bin/sh: 1: bc: not found
Kbuild:26: recipe for target 'include/generated/timeconst.h' failed
make[1]: *** [include/generated/timeconst.h] Error 127
make[1]: *** 正在等待未完成的任务....
```

A：原因是没有安装<code>bc</code>，执行<code>sudo apt-get install bc</code>将它安装上即可，出现类似的<code>xxx: not found</code>的错误都可以尝试使用<code>sudo apt-get install xxx</code>安装后再次尝试。
{% endnote %}

## 相关阅读

- {% post_link os-lab2 %}
- {% post_link os-lab-3-2 %}