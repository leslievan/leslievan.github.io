<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【教程】Ubuntu配置MySQL 8.0</title>
    <url>/2019/02/ubuntu-config-mysql8/</url>
    <content><![CDATA[<html><head></head><body><p>翻译自官方教程：<a href="https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/</a></p>
<a id="more"></a>
<h1 id="系统环境及配置" class="heading-control"><a class="heading-anchor" href="#系统环境及配置" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#系统环境及配置"></a> 系统环境及配置</h1>
<blockquote>
<p>Ubuntu 18.04</p>
<p>MySQL 8.0</p>
</blockquote>
<h1 id="下载安装mysql拓展包" class="heading-control"><a class="heading-anchor" href="#下载安装mysql拓展包" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#下载安装mysql拓展包"></a> 下载安装MySQL拓展包</h1>
<blockquote>
<p><a href="https://dev.mysql.com/downloads/repo/apt/" target="_blank" rel="noopener">官方最新下载地址</a></p>
<p><a href="https://pan.baidu.com/s/1OaHHJ_1DLUQVe0VdHQ91DA" target="_blank" rel="noopener">百度云下载地址</a>（提取码：9mmz，MD5: <code>65b0b081ce9cf90c7e2d3cc540aa8955</code>）</p>
<p>建议使用官方最新下载地址</p>
</blockquote>
<ol>
<li>
<p>下载后得到类似于<code>mysql-apt-config_0.x.x-x_all.deb</code>的安装包，打开终端，输入命令定位到安装包所在位置，并安装</p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i /PATH/mysql-apt-config_0.x.x-x_all</span></span><br></pre></td></tr></tbody></table></figure>
<p>将<code>mysql-apt-config_0.x.x-x_all.deb</code>置换为你所下载的文件名。</p>
</li>
<li>
<p>安装过程中将对<code>mysql-apt-config</code>进行配置，选择你所需要的MySQL版本，百度云提供的安装包默认版本为<code>mysql-8.0</code>，配置过程如下图所示，配置结束后选择<code>Ok</code>。<br>
<img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/02/2019-02-07-Ubuntu%E9%85%8D%E7%BD%AEMySQL8-1.png!on_blog" alt></p>
</li>
<li>
<p>打开终端，输入以下命令更新软件仓库：</p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h1 id="使用apt安装mysql" class="heading-control"><a class="heading-anchor" href="#使用apt安装mysql" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#使用apt安装mysql"></a> 使用APT安装MySQL</h1>
<p>使用如下命令安装MySQL：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></tbody></table></figure>
<p>这条命令将会同时安装<code>mysql-client</code>和<code>mysql-common</code>。</p>
<p>下载完安装包后将会提醒你配置<strong>根用户密码（root password）</strong>，请牢记该密码。</p>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】Ubuntu配置VMware Workstation</title>
    <url>/2019/02/ubuntu-config-vmware/</url>
    <content><![CDATA[<html><head></head><body><p>VMware Workstation是VMware公司推出的一款桌面虚拟计算软件，具有Windows、Linux 版本。此软件可以提供虚拟机功能，使计算机可以同时运行多个不同操作系统。</p>
<a id="more"></a>
<h1 id="系统环境" class="heading-control"><a class="heading-anchor" href="#系统环境" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#系统环境"></a> 系统环境</h1>
<blockquote>
<p>Ubuntu 18.04</p>
<p><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener" title="VMware官方下载地址">VMware Workstation 15</a></p>
</blockquote>
<h1 id="安装vmware-workstation" class="heading-control"><a class="heading-anchor" href="#安装vmware-workstation" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装vmware-workstation"></a> 安装VMware Workstation</h1>
<h2 id="定位到安装包所在文件夹" class="heading-control"><a class="heading-anchor" href="#定位到安装包所在文件夹" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#定位到安装包所在文件夹"></a> 定位到安装包所在文件夹</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> temp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">VMware-Workstation-Full-15.0.2-10952284.x86_64.bundle</span><br></pre></td></tr></tbody></table></figure>
<h2 id="更改文件权限" class="heading-control"><a class="heading-anchor" href="#更改文件权限" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#更改文件权限"></a> 更改文件权限</h2>
<p>Linux系统对于文件的默认权限是<code>rw-rw-r--</code>，即文件主和文件主同组用户对该文件都是可读可写，而其他用户只能读，<code>bundle</code>文件是Linux下的可执行文件，类似于Windows中的<code>exe</code>文件，因此我们需要为其增加可执行权限。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 484052</span><br><span class="line">-rw-rw-r-- 1 leslie leslie 495664015 2月   2 14:20 VMware-Workstation-Full-15.0.2-10952284.x86_64.bundle</span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x VMware-Workstation-Full-15.0.2-10952284.x86_64.bundle</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 484052</span><br><span class="line">-rwxrwxr-x 1 leslie leslie 495664015 2月   2 14:20 VMware-Workstation-Full-15.0.2-10952284.x86_64.bundle</span><br></pre></td></tr></tbody></table></figure>
<h2 id="安装vmware" class="heading-control"><a class="heading-anchor" href="#安装vmware" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装vmware"></a> 安装VMware</h2>
<p>执行<code>bundle</code>文件，VMware需要root权限，所以在前面添加上<code>sudo</code>。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./VMware-Workstation-Full-15.0.2-10952284.x86_64.bundle</span></span><br><span class="line">Extracting VMware Installer...done.</span><br></pre></td></tr></tbody></table></figure>
<p>然后选择接受协议，一路<code>next</code>下去就好了。</p>
<h2 id="安装vmware-tools" class="heading-control"><a class="heading-anchor" href="#安装vmware-tools" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装vmware-tools"></a> 安装VMware Tools</h2>
<blockquote>
<p><strong>VMware Tools</strong>是<strong>VMware</strong>虚拟机中自带的一种增强工具，相当于VirtualBox中的增强功能（Sun VirtualBox Guest Additions），是<strong>VMware</strong>提供的增强虚拟显卡和硬盘性能、以及同步虚拟机与主机时钟的驱动程序。</p>
</blockquote>
<p>简单地说，VMware Tools为你提供了诸如分辨率自适应（Autosize，虚拟机桌面大小与程序窗口保持一致）、主机与虚拟机之间剪贴板的共享（Clipboard Shared between Guest and Host）等功能，VMware默认是不安装的，需要手动进行配置。</p>
<p>VMware提供了多种方式进行安装：</p>
<h2 id="使用vmware自带的vmware-tools安装包进行安装" class="heading-control"><a class="heading-anchor" href="#使用vmware自带的vmware-tools安装包进行安装" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#使用vmware自带的vmware-tools安装包进行安装"></a> 使用VMware自带的VMware Tools安装包进行安装</h2>
<blockquote>
<p>官方教程：<a href="https://kb.vmware.com/articleview?docid=1022525&lang=zh_CN" target="_blank" rel="noopener">https://kb.vmware.com/articleview?docid=1022525&lang=zh_CN</a></p>
</blockquote>
<ol>
<li>
<p>启动此虚拟机。</p>
</li>
<li>
<p>使用具有管理员权限或root用户权限的帐户登录此虚拟机。</p>
</li>
<li>
<p>选择（顶端选项卡）：VM > 安装VMware Tools。</p>
</li>
<li>
<p>打开Ubuntu桌面上挂载的VMware Tools CD。</p>
</li>
<li>
<p>右键单击类似于VMwareTools.x.x.x-xxxx.tar.gz的文件名，单击<strong>复制</strong>，然后选择<strong>Ubuntu 桌面</strong>保存文件。</p>
</li>
<li>
<p>右键单击<strong>Ubuntu 桌面</strong>上的类似于VMwareTools.x.x.x-xxxx.tar.gz的文件名，单击解压到当前文件夹。</p>
</li>
<li>
<p>打开一个终端窗口。在「终端」中，运行下面的命令以导航到vmware-tools-distrib文件夹：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Desktop/vmware-tools-distrib</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>运行下面的命令来安装VMware Tools：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./vmware-install.pl -d</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意</strong>：-d假定您希望接受默认设置。如果不使用-d，请按<strong>Return</strong>接受默认值或提供您自己的答案。</p>
<p><em>请在确保你对设置项有所了解的情况下去除参数<code>-d</code></em></p>
</li>
<li>
<p>输入您的Ubuntu密码。</p>
</li>
<li>
<p>在VMware Tools安装完毕后重新启动Ubuntu虚拟机。</p>
</li>
</ol>
<h2 id="使用open-vm-tools" class="heading-control"><a class="heading-anchor" href="#使用open-vm-tools" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#使用open-vm-tools"></a> 使用open-vm-tools</h2>
<ol>
<li>
<p>打开终端输入</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install open-vm-tools -y</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>在<code>open-vm-tools</code>安装完毕后重新启动Ubuntu虚拟机。</p>
</li>
</ol>
<div class="note default">
            <p>经测试，<a href="#%E4%BD%BF%E7%94%A8open-vm-tools">第二种方法</a>安装的<code>open-vm-tools</code>只是<a href="#%E4%BD%BF%E7%94%A8VMware%E8%87%AA%E5%B8%A6%E7%9A%84VMware-Tools%E5%AE%89%E8%A3%85%E5%8C%85%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85">第一种方法</a>安装的完整版VMware Tools的一个子集，缺失了部分功能，其中一个重要的功能就是<strong>剪贴板共享</strong>，所以如果对该功能有强烈需求的用户，请使用第一种方法进行安装。</p>
          </div>
<h1 id="卸载" class="heading-control"><a class="heading-anchor" href="#卸载" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h1>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vmware-installer -u vmware-workstation</span></span><br></pre></td></tr></tbody></table></figure>
<p>随后会跳出卸载界面，跟着提示卸载就行。</p>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Software</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】加速apt（apt-get速度慢）</title>
    <url>/2019/03/apt-use-mirror/</url>
    <content><![CDATA[<html><head></head><body><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-24-8376b517-0.jpg!on_blog" alt></p>
<p>使用OPSX镜像站为APT进行加速。</p>
<a id="more"></a>
<p>Ubuntu默认使用其<a href="archive.ubuntu.com">Main Server</a>作为默认下载源，由于这个下载源在国外，国内访问源的速度会非常地慢（可能只有几KB到几十KB），庆幸的是，许多高校和公司为此建立了一些镜像站，诸如阿里巴巴开源镜像站<a href="https://opsx.alibaba.com" target="_blank" rel="noopener">OPSX</a>、<a href="https://mirrors.tuna.tsinghua.edu.cn" target="_blank" rel="noopener">清华大学开源软件镜像站</a>，这些镜像站的存在让我可以更方便、更快速地获取各种开源软件（包括但不限于Linux在内的一系列系统/应用软件）。</p>
<p>这里说明三种更改默认下载源的方法。</p>
<h2 id="命令行配置" class="heading-control"><a class="heading-anchor" href="#命令行配置" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#命令行配置"></a> 命令行配置</h2>
<blockquote>
<p>新手推荐使用(<a href="#%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E9%85%8D%E7%BD%AE">图形界面配置</a>）</p>
</blockquote>
<p>一般情况下，将<code>/etc/apt/sources.list</code>文件中Ubuntu默认的源地址<code>http://archive.ubuntu.com/</code>替换为镜像的地址即可。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 这里以清华镜像为例</span></span><br><span class="line"><span class="comment"># Ubuntu 1604</span></span><br><span class="line">$ sudo rm /etc/apt/sources.list && sudo wget https://tinyurl.com/y28j6bh6 -O /etc/apt/sources.list && sudo apt-get update</span><br><span class="line"><span class="comment"># Ubuntu 1804</span></span><br><span class="line">$ sudo rm /etc/apt/sources.list && sudo wget https://tinyurl.com/y28j6bh6 -O /etc/apt/sources.list && sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清华tuna协会也推出了「Oh-My-TUNA」脚本，具体的可以看最后一节</span></span><br><span class="line">$ wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py</span><br><span class="line"><span class="comment"># For yourself</span></span><br><span class="line">$ python oh-my-tuna.py</span><br><span class="line"><span class="comment"># ...or for everyone!</span></span><br><span class="line">sudo python oh-my-tuna.py --global</span><br></pre></td></tr></tbody></table></figure>
<p>这将解决由于下载服务器在国外而导致的速度过慢以至于无法下载的问题。</p>
<h2 id="图形界面配置" class="heading-control"><a class="heading-anchor" href="#图形界面配置" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#图形界面配置"></a> 图形界面配置</h2>
<p>图形界面操作为：<code>Software & Update</code>-><code>Download from</code>，选择<code>China</code>下的<code>mirrors.aliyun.com</code>。</p>
<blockquote>
<p>Bilibili：<a href="https://www.bilibili.com/video/av47223665/" target="_blank" rel="noopener">https://www.bilibili.com/video/av47223665/</a></p>
</blockquote>
<iframe width="100%" height="500px" src="//player.bilibili.com/player.html?aid=47223665&cid=82702213&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
## 「一键使用TUNA」
<blockquote>
<p>清华大学 TUNA 协会，全名清华大学学生网络与开源软件协会，是由清华大学热爱网络技术和开源软件的极客组成的学生技术社团。</p>
</blockquote>
<p>清华开源软件镜像站由TUNA协会运行维护，为了方便用户使用他们推出了「一键使用TUNA」的服务，具体操作及介绍，请直接查看其项目主页，这里不越俎代庖。</p>
<p>oh-my-tuna介绍：<a href="https://mirrors.tuna.tsinghua.edu.cn/news/#oh-my-tuna" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/news/#oh-my-tuna</a></p>
<p>oh-my-tuan主页：<a href="https://tuna.moe/oh-my-tuna/" target="_blank" rel="noopener">https://tuna.moe/oh-my-tuna/</a></p>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Software</tag>
        <tag>加速</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】加速git（push/clone速度慢）</title>
    <url>/2019/04/git-use-proxy/</url>
    <content><![CDATA[<html><head></head><body><p>作为一名CS专业的学生，我们大部分时候都在和代码打交道，那么就不得不知道<code>git</code>和<a href="https://github.com" target="_blank" rel="noopener"><code>GitHub</code></a>了，<code>git</code>最基本的命令就是使用<code>git clone</code>从代码托管平台下载代码以及使用<code>git push</code>将本地更改推送到远程仓库，然而由于众所周知的原因，世界上最大的代码托管平台<code>GitHub</code>在国内访问的速度实在堪忧，这里提供一些网络加速的方法。</p>
<a id="more"></a>
<h1 id="为git使用代理" class="heading-control"><a class="heading-anchor" href="#为git使用代理" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#为git使用代理"></a> 为git使用代理</h1>
<p>如果你已经拥有了一些代理软件，那么直接为<code>git</code>设置代理是最好的提速方法，这里以<code>ss</code>为例，假设本地代理地址为<code>127.0.0.1：1080</code>，那么你可以使用以下命令为<code>git</code>设置代理：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> http options</span></span><br><span class="line">git config --global http.proxy "socks5h://127.0.0.1:1080"</span><br><span class="line"><span class="meta">#</span><span class="bash"> unknown section name</span></span><br><span class="line">git config --global https.proxy "socks5h://127.0.0.1:1080"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看更改是否成功</span></span><br><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消代理</span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></tbody></table></figure>
<p>这一方法可以加速克隆使用http/https协议进行传输的仓库，使用ssh协议的需要其他设置，这里不加以阐述。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> http/https协议</span></span><br><span class="line">git clone https://github.com/leslievan/verilog.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh协议</span></span><br><span class="line">git clone git@github.com:leslievan/verilog,git</span><br></pre></td></tr></tbody></table></figure>
<h1 id="修改host文件" class="heading-control"><a class="heading-anchor" href="#修改host文件" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#修改host文件"></a> 修改host文件</h1>
<p>在<code>git clone</code>或<code>git push</code>时，实际上并不是直接向<code>github.com</code>发送请求，而是对<code>github.global.ssl.fastly.net</code>发送请求与通信，Fastly公司在中国有着众多的CDN节点，GitHub可能因为成本或者其他原因，并没有在中国搭设自己专属的CDN节点，我们可以通过修改<code>host</code>文件来加速对这个域名的访问。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># windows下修改C:\Windows\System32\drivers\etc\hosts</span><br><span class="line"># Linux/Mac下修改/etc/hosts</span><br><span class="line"># 在最后加上</span><br><span class="line"></span><br><span class="line">151.101.77.194  github.global.ssl.fastly.net</span><br><span class="line">13.229.188.59   github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">151.101.76.249  global-ssl.fastly.net</span><br></pre></td></tr></tbody></table></figure>
<p>然后刷新DNS缓存。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># windows</span><br><span class="line">ipconfig /flushdns</span><br><span class="line"># linux/mac</span><br><span class="line">sudo /etc/init.d/network-manager restart</span><br></pre></td></tr></tbody></table></figure>
<p>如果网络没问题的话，修改后的速度一般都能达到<code>MB/s</code>的级别。</p>
<h1 id="git-shallow-clone" class="heading-control"><a class="heading-anchor" href="#git-shallow-clone" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#git-shallow-clone"></a> git shallow clone</h1>
<p><code>git clone</code>默认是将整个项目全须全尾地下载到本地，实际上我们大部分时候都只是想要最新的版本，下载整个项目是无用的且花费较大的，这时候我们可以使用：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone --depth=1 https://github.com/leslievan/verilog.git</span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>--depth=1</code>代表最新的版本，通过这一参数的限定可以大大减少下载的数据量，如果你的网速较慢且无法改变，无法开源那么不妨尝试节流。</p>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>【笔记】Ubuntu美化装机全步骤</title>
    <url>/2019/04/config-ubuntu/</url>
    <content><![CDATA[<html><head></head><body><p>Ubuntu重装了太多太多次，这次因为安装CUDA，结果把显卡驱动弄坏了，折腾了半小时没救回来，遂重装了事，记录下一系列的步骤，步骤仅供我自己参考，<s>如有按图索骥然后弄崩系统的，概不负责</s>，有兴趣参考的可以邮件给我或在下方评论。</p>
<a id="more"></a>
<h2 id="theme" class="heading-control"><a class="heading-anchor" href="#theme" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#theme"></a> Theme</h2>
<h3 id="font-icon-cursor" class="heading-control"><a class="heading-anchor" href="#font-icon-cursor" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#font-icon-cursor"></a> Font & Icon & Cursor</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> fonts</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir .fonts</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp themes/fonts/* .fonts</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkfontscale && mkfontdir && <span class="built_in">fc</span>-cache -fv</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> icon</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i install themes/papirus-icon-theme_*.deb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cursor</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir .icons</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp themes/icons/* .icons</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell color theme</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> themes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./gosh.sh</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="theme-2" class="heading-control"><a class="heading-anchor" href="#theme-2" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#theme-2"></a> Theme</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gnome-tweak-tool gnome-shell-extensions</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/gdm3 restart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/vinceliuice/vimix-gtk-themes.git vimix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> vimix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./vimix-installer</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="time-language" class="heading-control"><a class="heading-anchor" href="#time-language" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#time-language"></a> Time Language</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/default/locale</span></span><br><span class="line">:%s/zh_CN/en_US/g</span><br><span class="line">:x</span><br></pre></td></tr></tbody></table></figure>
<h2 id="driver" class="heading-control"><a class="heading-anchor" href="#driver" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#driver"></a> Driver</h2>
<h3 id="display" class="heading-control"><a class="heading-anchor" href="#display" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#display"></a> Display</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install nvidia-361</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reboot</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="printer" class="heading-control"><a class="heading-anchor" href="#printer" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#printer"></a> Printer</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hp-setup -i</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="software" class="heading-control"><a class="heading-anchor" href="#software" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#software"></a> Software</h2>
<h3 id="fcitx-sogoupinyin" class="heading-control"><a class="heading-anchor" href="#fcitx-sogoupinyin" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#fcitx-sogoupinyin"></a> Fcitx & SogouPinyin</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install fcitx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb</span></span><br><span class="line">Selecting previously unselected package sogoupinyin.</span><br><span class="line">(Reading database ... 150921 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../sogoupinyin_2.2.0.0108_amd64.deb ...</span><br><span class="line">Unpacking sogoupinyin (2.2.0.0108) ...</span><br><span class="line">dpkg: dependency problems prevent configuration of sogoupinyin:</span><br><span class="line"> sogoupinyin depends on libfcitx-qt0 | fcitx-libs-qt; however:</span><br><span class="line">  Package libfcitx-qt0 is not installed.</span><br><span class="line">  Package fcitx-libs-qt is not installed.</span><br><span class="line"> sogoupinyin depends on libopencc2 | libopencc1; however:</span><br><span class="line">  Package libopencc2 is not installed.</span><br><span class="line">  Package libopencc1 is not installed.</span><br><span class="line"> sogoupinyin depends on fcitx-libs (>= 4.2.7); however:</span><br><span class="line">  Package fcitx-libs is not installed.</span><br><span class="line"> sogoupinyin depends on libqtwebkit4 (>= 2.1.0~2011week13); however:</span><br><span class="line">  Package libqtwebkit4 is not installed.</span><br><span class="line"></span><br><span class="line">dpkg: error processing package sogoupinyin (--install):</span><br><span class="line"> dependency problems - leaving unconfigured</span><br><span class="line">Processing triggers for mime-support (3.60ubuntu1) ...</span><br><span class="line">Processing triggers for libglib2.0-0:amd64 (2.56.3-0ubuntu0.18.04.1) ...</span><br><span class="line">No such key 'Gtk/IMModule' in schema 'org.gnome.settings-daemon.plugins.xsettings' as specified in override file '/usr/share/glib-2.0/schemas/50_sogoupinyin.gschema.override'; ignoring override for this key.</span><br><span class="line">Processing triggers for gnome-menus (3.13.3-11ubuntu1.1) ...</span><br><span class="line">Processing triggers for desktop-file-utils (0.23-1ubuntu3.18.04.2) ...</span><br><span class="line">Processing triggers for shared-mime-info (1.9-2) ...</span><br><span class="line">Processing triggers for hicolor-icon-theme (0.17-2) ...</span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> sogoupinyin</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get -f install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reboot</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="vmware" class="heading-control"><a class="heading-anchor" href="#vmware" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#vmware"></a> VMware</h3>
<h3 id="typora" class="heading-control"><a class="heading-anchor" href="#typora" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#typora"></a> Typora</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> or run:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span></span><br><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> add Typora<span class="string">'s repository</span></span></span><br><span class="line">sudo add-apt-repository 'deb https://typora.io/linux ./'</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> install typora</span></span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></tbody></table></figure>
<h3 id="network" class="heading-control"><a class="heading-anchor" href="#network" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#network"></a> Network</h3>
<p><strong>Shadowsocks && Privoxy</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install privoxy shadowsocks</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/shadowsocks/config.json</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/privoxy/config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Start</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sslocal -c /etc/shadowsocks/config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service privoxy start</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="hugo" class="heading-control"><a class="heading-anchor" href="#hugo" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#hugo"></a> Hugo</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/gohugoio/hugo.git <span class="variable">$GOPATH</span>/hugo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/hugo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="some" class="heading-control"><a class="heading-anchor" href="#some" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#some"></a> Some…</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i opt/deb/*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get -f install</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="configuration" class="heading-control"><a class="heading-anchor" href="#configuration" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#configuration"></a> Configuration</h2>
<h3 id="pip-mirror" class="heading-control"><a class="heading-anchor" href="#pip-mirror" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#pip-mirror"></a> pip mirror</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir .pip</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch .pip/pip.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n[install]\ntrusted-host = pypi.tuna.tsinghua.edu.cn'</span> > .pip/pip.conf</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="apt-mirror" class="heading-control"><a class="heading-anchor" href="#apt-mirror" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#apt-mirror"></a> apt mirror</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">python3 config/oh-my-tuna.py</span><br></pre></td></tr></tbody></table></figure>
<h3 id="some-2" class="heading-control"><a class="heading-anchor" href="#some-2" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#some-2"></a> Some…</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install zsh zsh-antigen git curl vim silversearcher-ag redshift trash-cli aria2</span></span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th>opt</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td>zsh</td>
<td>A shell designed for interactive use</td>
</tr>
<tr>
<td>zsh-antigen</td>
<td>A small set of functions that help you easily manage your shell(zsh) plugins</td>
</tr>
<tr>
<td>git</td>
<td>A free and open source distributed version control system</td>
</tr>
<tr>
<td>curl</td>
<td>A command line tool and library for transferring data with URL syntax</td>
</tr>
<tr>
<td>vim</td>
<td>A greatly improved version of the good old UNIX editor Vi</td>
</tr>
<tr>
<td>silversearcher-ag</td>
<td>A code searching tool similar to <code>ack</code>, with a focus on speed.</td>
</tr>
<tr>
<td>redshift</td>
<td>Adjusts the color temperature of your screen according to your surroundings.</td>
</tr>
<tr>
<td>trash-cli</td>
<td>Command Line Interface to <a href="http://FreeDesktop.org" target="_blank" rel="noopener">FreeDesktop.org</a> Trash.</td>
</tr>
<tr>
<td>aria2</td>
<td>Aria2 is a lightweight multi-protocol & multi-source command-line download utility.</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="shell" class="heading-control"><a class="heading-anchor" href="#shell" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#shell"></a> shell</h4>
<p>修改默认shell</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chsh -s /bin/zsh</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="aria2" class="heading-control"><a class="heading-anchor" href="#aria2" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#aria2"></a> aria2</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Edit config</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.config/.aria2.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Start aria2c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> aria2c --conf-path ~/.config/.aria2.conf</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="git" class="heading-control"><a class="heading-anchor" href="#git" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#git"></a> git</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">'username'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">'useremail'</span></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="apt-fast" class="heading-control"><a class="heading-anchor" href="#apt-fast" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#apt-fast"></a> apt-fast</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt--repository ppa:apt-fast/stable</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install apt-fast</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reboot</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="coding" class="heading-control"><a class="heading-anchor" href="#coding" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#coding"></a> Coding</h2>
<h3 id="jetbrains" class="heading-control"><a class="heading-anchor" href="#jetbrains" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#jetbrains"></a> Jetbrains</h3>
<p>Install Jetbrains ToolBox.</p>
<h3 id="python" class="heading-control"><a class="heading-anchor" href="#python" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#python"></a> Python</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install python3-pip python3-opencv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 install numpy torch scipy PIL</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="cuda" class="heading-control"><a class="heading-anchor" href="#cuda" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#cuda"></a> CUDA</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Disable graphical target first.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">set</span>-default multi-user.target</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reboot</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Login, and install without driver first. Be silent to install driver next.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh cuda_10.1.105_418.39_linux.run --silent --driver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Enable graphical target.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">set</span>-default graphical.target</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reboot</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="go" class="heading-control"><a class="heading-anchor" href="#go" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#go"></a> Go</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -C /usr/<span class="built_in">local</span> -xzf go1.12.4.linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span></span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Software</tag>
        <tag>Gnome</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】安装&amp;加速Rust</title>
    <url>/2019/04/rust-cargo-use-mirror/</url>
    <content><![CDATA[<html><head></head><body><p>和<code>apt</code>、<code>pip</code>等一样，<code>Rust</code>的源同样也在国外，被GFW拒之门外，速度实在难以言表，这里介绍安装过程以及如何使用中科大的源为<code>Rust</code>和<code>Cargo</code>加速。</p>
<a id="more"></a>
<h1 id="安装" class="heading-control"><a class="heading-anchor" href="#安装" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1>
<h2 id="ubuntu源" class="heading-control"><a class="heading-anchor" href="#ubuntu源" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#ubuntu源"></a> Ubuntu源</h2>
<p><code>rustc</code>是Rust的软件包，默认已被收录，如果不需求最新版本，可以直接使用<code>apt</code>进行安装，前面已经有一篇文章介绍了<a href="/2019/03/apt-use-mirror/">如何加速apt</a>：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install rustc cargo</span><br></pre></td></tr></tbody></table></figure>
<h2 id="rustup" class="heading-control"><a class="heading-anchor" href="#rustup" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#rustup"></a> Rustup</h2>
<p>在终端里面输入：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></tbody></table></figure>
<p>之后跟随提示所有选项选择默认即可。</p>
<h1 id="使用中科大源进行加速" class="heading-control"><a class="heading-anchor" href="#使用中科大源进行加速" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#使用中科大源进行加速"></a> 使用中科大源进行加速</h1>
<p>在<code>~/.cargo/config</code>添加以下内容：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[registry]</span><br><span class="line">index = "git://mirrors.ustc.edu.cn/crates.io-index"</span><br></pre></td></tr></tbody></table></figure>
<p>如果所处的环境中不允许使用 git 协议, 可以把上述地址改为</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">index = "http://mirrors.ustc.edu.cn/crates.io-index"</span><br></pre></td></tr></tbody></table></figure>
<p>如果 cargo 版本为 0.13.0 或以上, 需要更改<code>~/.cargo/config</code>为以下内容：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = "https://github.com/rust-lang/crates.io-index"</span><br><span class="line">replace-with = 'ustc'</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = "git://mirrors.ustc.edu.cn/crates.io-index"</span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Software</tag>
        <tag>加速</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>【OS】HDU 操作系统实验</title>
    <url>/2019/04/os-lab/</url>
    <content><![CDATA[<html><head></head><body><ul>
<li>
<a href="/2019/01/os-lab1/" title="Lab1-Linux内核编译及添加系统调用">Lab1-Linux内核编译及添加系统调用</a>
</li>
<li>
<a href="/2019/03/os-lab2/" title="Lab2-Linux内核模块编程">Lab2-Linux内核模块编程</a>
</li>
<li>
<a href="/2019/04/os-lab-3-2/" title="Lab3-Linux进程管理（二）管道通信">Lab3-Linux进程管理（二）管道通信</a>
</li>
<li><a href="https://github.com/leslievan/Operator_System" target="_blank" rel="noopener">Lab3-Linux进程管理（三）消息队列</a></li>
<li><a href="https://github.com/leslievan/Operator_System" target="_blank" rel="noopener">Lab3-Linux进程管理（四）共享内存</a></li>
<li><a href="https://github.com/leslievan/Operator_System" target="_blank" rel="noopener">Lab5-Linux文件系统</a></li>
</ul>
<a id="more"></a>
<a class="btn" href="https://leslie-cloud.oss-accelerate.aliyuncs.com/files/Operate_System/Operator_System-1.0.zip" target="_blank" rel="noopener">
            <i class="fa fa-"></i>点此下载源码
          </a>
<h2 id="hdu-os-lab1-linux内核编译及添加系统调用" class="heading-control"><a class="heading-anchor" href="#hdu-os-lab1-linux内核编译及添加系统调用" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#hdu-os-lab1-linux内核编译及添加系统调用"></a> HDU-OS-Lab1-Linux内核编译及添加系统调用</h2>
<p>添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级prio。</p>
<blockquote>
<p>视频教程地址：</p>
<p><a href="https://www.bilibili.com/video/av47274857" target="_blank" rel="noopener">https://www.bilibili.com/video/av47274857</a></p>
<p>源码地址：</p>
<p><a href="https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab1" target="_blank" rel="noopener">https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab1</a></p>
</blockquote>
<a href="/2019/01/os-lab1/" title="阅读更多">阅读更多</a>
<h2 id="hdu-os-lab2-linux内核模块编程" class="heading-control"><a class="heading-anchor" href="#hdu-os-lab2-linux内核模块编程" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#hdu-os-lab2-linux内核模块编程"></a> HDU-OS-Lab2-Linux内核模块编程</h2>
<p>Linux内核采用了整体结构，上一个实验体会了编译内核时间的冗长与繁杂，一步错就要重新编译，这虽然提高了效率，但同时也让后续的维护变得困难，在这个基础上，Linux内核引入了动态模块机制加以改进。</p>
<blockquote>
<p>视频教程地址：</p>
<p><a href="https://www.bilibili.com/video/av47412869/" target="_blank" rel="noopener">https://www.bilibili.com/video/av47412869/</a></p>
<p>源码地址：</p>
<p><a href="https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab2" target="_blank" rel="noopener">https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab2</a></p>
</blockquote>
<a href="/2019/03/os-lab2/" title="阅读更多">阅读更多</a>
<h2 id="hdu-os-lab3-linux进程管理二管道通信" class="heading-control"><a class="heading-anchor" href="#hdu-os-lab3-linux进程管理二管道通信" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#hdu-os-lab3-linux进程管理二管道通信"></a> HDU-OS-Lab3-Linux进程管理（二）管道通信</h2>
<p>实验三的知识点是进程通信，进程通信的方式多种多样，既包括锁机制、信号量机制在内的低级通信方式，低级在于其交换的信息量少且效率较低，又包括共享服务器、消息传递系统、管道通信以及客户-服务器系统通信在内的高级通信方式，本实验是实验三的第二个部分，介绍了管道通信方式的基本原理以及具体实现。</p>
<blockquote>
<p>源码地址：</p>
<p><a href="https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab3/Operator_System_Exp3_2" target="_blank" rel="noopener">https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab3/Operator_System_Exp3_2</a></p>
</blockquote>
<a href="/2019/04/os-lab-3-2/" title="阅读更多">阅读更多</a>
<h2 id="hdu-os-lab3-linux进程管理三消息队列" class="heading-control"><a class="heading-anchor" href="#hdu-os-lab3-linux进程管理三消息队列" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#hdu-os-lab3-linux进程管理三消息队列"></a> HDU-OS-Lab3-Linux进程管理（三）消息队列</h2>
<p>本实验是实验三的第三个部分，介绍了利用消息队列通信机制实现两个线程间通信的方法。</p>
<blockquote>
<p>源码地址：</p>
<p><<a href="https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab3/Operator_System_Exp3_3" target="_blank" rel="noopener">https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab3/Operator_System_Exp3_3</a></p>
</blockquote>
<a href="/2019/04/os-lab-3-3/" title="阅读更多">阅读更多</a></body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】Ubuntu使用IPv6拨号连接</title>
    <url>/2019/04/ubuntu-ipv6-config/</url>
    <content><![CDATA[<html><head></head><body><blockquote>
<p><strong>IPv6</strong>是下一版本的互联网协议，也可以说是下一代互联网的协议，它的提出最初是因为随着互联网的迅速发展，<strong>IPv4</strong>定义的有限地址空间将被耗尽，地址空间的不足必将妨碍互联网的进一步发展。 为了扩大地址空间，拟通过<strong>IPv6</strong>重新定义地址空间。<strong>IPv6</strong>采用128位地址长度，几乎可以不受限制地提供地址。</p>
</blockquote>
<a id="more"></a>
<h2 id="use-ipv6" class="heading-control"><a class="heading-anchor" href="#use-ipv6" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#use-ipv6"></a> Use IPv6</h2>
<p>拨号连接默认不使用<code>IPv6</code>，但提供了简单的操作让我们去设置<code>IPv6</code>，使用<code>man pppd | grep ipv6</code>可以看到：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> man pppd | grep ipv6</span></span><br><span class="line">       +ipv6  Enable the IPv6CP and IPv6 protocols.</span><br><span class="line">       ipv6 <local_interface_identifier>,<remote_interface_identifier></span><br><span class="line">              ipv6cp-use-ipaddr option is given, the local identifier  is  the</span><br><span class="line">              MAC address, ipv6cp-use-persistent option can be used to replace</span><br><span class="line">              the ipv6 <local>,<remote> option. Otherwise  the  identifier  is</span><br><span class="line">       ipv6cp-accept-local</span><br><span class="line">       ipv6cp-accept-remote</span><br><span class="line">       ipv6cp-max-configure n</span><br><span class="line">       ipv6cp-max-failure n</span><br><span class="line">       ipv6cp-max-terminate n</span><br><span class="line">       ipv6cp-restart n</span><br><span class="line">       noipv6 Disable  IPv6CP  negotiation and IPv6 communication. This option</span><br><span class="line">       /etc/ppp/ipv6-up</span><br><span class="line">       /etc/ppp/ipv6-down</span><br><span class="line">              with the same parameters as the ipv6-up script.</span><br></pre></td></tr></tbody></table></figure>
<p>第一行就提供了一个参数，用以支持<code>IPv6</code>，我们只需要在配置文件<code>/etc/ppp/peers/dsl-provider</code>中添加一行<code>+ipv6</code>即可：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">echo</span> <span class="string">"+ipv6"</span> >> /etc/ppp/peers/dsl-provider</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="set-dns" class="heading-control"><a class="heading-anchor" href="#set-dns" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#set-dns"></a> Set DNS</h2>
<p>Ubuntu 18.04使用<code>systemd-resolved</code>管理DNS。</p>
<blockquote>
<p>有三种处理 /etc/resolv.conf 文件(参见 resolv.conf(5)) 的方式：</p>
<ul>
<li>创建 /etc/resolv.conf 软连接，并将其指向 /usr/lib/systemd/resolv.conf 文件(其中仅设置了单独一个 127.0.0.53 DNS服务器)。 这是推荐的首选方式。</li>
<li>创建 /etc/resolv.conf 软连接， 并将其指向由 systemd-resolved 实时更新的 /run/systemd/resolve/resolv.conf 文件。 注意，此文件中只包含所有已知的全局DNS服务器，而不包含针对特定网络接口设置的DNS服务器。 注意，应用程序不应该直接使用 /run/systemd/resolve/resolv.conf 文件， 而是应该继续使用 /etc/resolv.conf 文件。 使用这种方式，所有绕过本地 DNS API 的客户端也将同样绕开 systemd-resolved 服务， 直接使用已知的DNS服务器。</li>
<li>由其他软件包或系统管理员维护 /etc/resolv.conf 的内容。 在这种情况下， systemd-resolved 将会从中读取全局DNS配置。 也就是说，systemd-resolved 只是一个读取 /etc/resolv.conf 配置文件的使用者， 而非此文件的提供者。</li>
</ul>
</blockquote>
<p>注意，上述三种处理方式是自动感知的(不需要特别的配置)，完全取决于 /etc/resolv.conf 是否为软连接， 以及软连接指向的目标。</p>
<p>在这里我们使用最后一种方法，在<code>Home</code>目录下创建一个配置文件，填入我们想要使用的DNS地址，然后将其软链接到<code>/etc/resolv.conf</code>。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch .resolv.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"nameserver 240c::6666\nnameserver 240c::6644"</span> >> ~/.resolv.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /etc/resolv.conf && sudo ln -s ~/.resolv.conf /etc/resolv.conf</span></span><br></pre></td></tr></tbody></table></figure>
<p>执行完以上命令你可以使用<code>systemd-resolve --status</code>，使用键盘上的<span class="emoji" alias="arrow_down" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2b07.png?v8">⬇</span>滚动输出，找到拨号连接（一般是<code>ppp*</code>），即可查看当前的DNS设置是否生效。</p>
<h2 id="reference" class="heading-control"><a class="heading-anchor" href="#reference" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ol>
<li><a href="https://dns.icoa.cn/ipv6/" target="_blank" rel="noopener">IPv6 DNS 免费公共服务器地址大全Public IPv6 DNS Server - DNS …</a></li>
<li><a href="http://www.jinbuguo.com/systemd/systemd-resolved.service.html" target="_blank" rel="noopener">systemd-resolved.service 中文手册 [金步国]</a></li>
<li><a href="https://groups.google.com/forum/#!topic/xidian_linux/p3XW0jJz4Wo" target="_blank" rel="noopener">IPv6 Over PPPoE - Google 网上论坛</a></li>
</ol>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>DNS</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】Manjaro升级内核后无法打开VMware</title>
    <url>/2019/06/manjaro-cannot-open-vmware-after-upgrade/</url>
    <content><![CDATA[<html><head></head><body><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/06/20190625-00-00.jpg!on_blog" alt><br>
在Ubuntu又一次搞坏了CUDA的驱动之后，我投向了Manjaro的怀抱，重新进入了双系统的状态，VMware还是要安装的，安装的步骤倒是和Ubuntu没有什么不同。Manjaro默认的内核头文件是3.16版本的，我升级到了和内核相匹配的4.19，然后就出问题了，找了几种方法后终于解决，遂记录于此，万一下次还碰到了呢？</p>
<a id="more"></a>
<h2 id="故障分析" class="heading-control"><a class="heading-anchor" href="#故障分析" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#故障分析"></a> 故障分析</h2>
<ul>
<li>更新了内核 || 启用安全启动了UEFI引导</li>
<li>发现错误：<br>
<code>Cannot open /dev/vmmon: No such file or directory. Please make sure that the kernel module 'vmmon' is loaded</code></li>
</ul>
<h2 id="解决方法" class="heading-control"><a class="heading-anchor" href="#解决方法" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2>
<h3 id="vmware-forumunsolved" class="heading-control"><a class="heading-anchor" href="#vmware-forumunsolved" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#vmware-forumunsolved"></a> VMware Forum[Unsolved]</h3>
<ol>
<li>
<p>Generate a key pair using the openssl to sign vmmon and vmnet modules:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ openssl req -new -x509 -newkey rsa:2048 -keyout MOK.priv -outform DER -out MOK.der -nodes -days 36500 -subj <span class="string">"/CN=VMware/"</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>Sign the modules using the generated key by running these commands:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sudo /usr/src/linux-headers-`uname -r`/scripts/sign-file sha256 ./MOK.priv ./MOK.der $(modinfo -n vmmon)</span><br><span class="line">$ sudo /usr/src/linux-headers-`uname -r`/scripts/sign-file sha256 ./MOK.priv ./MOK.der $(modinfo -n vmnet)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>Import the public key to the system’s MOK list by running this command:</p>
</li>
<li>
<p>Confirm a password for this MOK enrollment request.</p>
</li>
<li>
<p>Reboot your machine. Follow the instructions to complete the enrollment from the UEFI console.</p>
</li>
</ol>
<h3 id="manjaro-forumsolved" class="heading-control"><a class="heading-anchor" href="#manjaro-forumsolved" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#manjaro-forumsolved"></a> Manjaro Forum[Solved]</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/mkubecek/vmware-host-modules</span><br><span class="line">$ <span class="built_in">cd</span> vmware-host-modules && git checkout -t origin/workstation-xx.x.x</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install && modprobe --force-vermagic -a vmw_vmci vmmon</span><br></pre></td></tr></tbody></table></figure>
<p>将第二行中的<code>xx.x.x</code>换成vmware对应的版本号即可</p>
<h2 id="讨论" class="heading-control"><a class="heading-anchor" href="#讨论" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h2>
<p>很遗憾VMware官方所描述的方法没（然）有（并）用（卵），因为Manjaro我根本找不到它的<code>linux-headers</code>在哪里……令人窒息，Manjaro论坛里面给出的解决方案和VMware官方的本质上是一样的，都是让<code>vmmon</code>通过内核的模块验证，这里就牵扯到了Linux内核模块的版本检查机制，内核在装载模块的时候会使用CRC和Vermagic两种解决方法，后者保存了模块编译时的内核版本以及SMP等配置信息，似乎是编译<code>vmmon</code>时所用的内核和当前内核版本不一致导致了这个问题。</p>
<p>PS：官方给的方案更复杂一点……总给我一种比后者更安全的感觉，不过我还是选择简单的<span class="emoji" alias="grin" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span>（误）。</p>
<h2 id="引用" class="heading-control"><a class="heading-anchor" href="#引用" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<ol>
<li><a href="https://kb.vmware.com/s/article/2146460" target="_blank" rel="noopener">“Cannot open /dev/vmmon: No such file or directory” error when powering on a VM (2146460)</a></li>
<li><a href="https://forum.manjaro.org/t/vmware-vmmon-module-error/39429" target="_blank" rel="noopener">Vmware vmmon module error</a></li>
<li><a href="https://wiki.archlinux.org/index.php/VMware_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">VMware (简体中文) - ArchWiki</a></li>
<li><a href="https://zh.opensuse.org/SDB:%E5%AE%89%E8%A3%85_VMware" target="_blank" rel="noopener">SDB_安装 VMware - openSUSE Wiki</a></li>
</ol>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Software</tag>
        <tag>VMware</tag>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】Manjaro安装Miniconda</title>
    <url>/2019/07/manjaro-install-conda/</url>
    <content><![CDATA[<html><head></head><body><p>Manjaro Linux是基于Arch Linux的Linux发行版，在经过这段时间的使用之后原本信仰Ubuntu的我不禁说一句真香。</p>
<p>Conda是一个python的包管理/环境管理器，因为代码的新旧程度不同，有时候需要安装多个版本的python，Linux下还好些，Windows下对于这个问题的解决方案比较复杂，经常需要对本身的环境变量进行很多设置，在这种情况下Conda体现了它别样的魅力。话扯远了，这次正好记录一下在Manjaro安装Conda时碰到的问题及解决方法。</p>
<a id="more"></a>
<h2 id="安装" class="heading-control"><a class="heading-anchor" href="#安装" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<h3 id="pacmanyay安装" class="heading-control"><a class="heading-anchor" href="#pacmanyay安装" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#pacmanyay安装"></a> pacman/yay安装</h3>
<p>只需要一行代码就可以安装上：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用pacman</span></span><br><span class="line">$ sudo pacman -Ss miniconda3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用yay</span></span><br><span class="line">$ sudo yay -Ss miniconda3</span><br></pre></td></tr></tbody></table></figure>
<h3 id="手动安装" class="heading-control"><a class="heading-anchor" href="#手动安装" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#手动安装"></a> 手动安装</h3>
<p>从清华TUNA镜像站的<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">Anaconda镜像</a>下载你所需要的版本，一般是将滚动条拉到最下面下载最新的版本也即<code>Miniconda-latest-**-**</code>，根据你的系统选择合适的版本。我选择的是<code>Miniconda3-latest-Linux-x86_64.sh</code>。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sh Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></tbody></table></figure>
<p>然后根据提示阅读并同意相关协议，选择安装位置开始安装，可以直接选择选默认的，一般是<code>$HOME/miniconda3</code>，可以修改但是需要记住修改后的位置，因为之后要用。</p>
<h2 id="载入" class="heading-control"><a class="heading-anchor" href="#载入" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#载入"></a> 载入</h2>
<p>在安装之后并不能直接用conda，还需要设置一下环境，将<code>miniconda3/bin</code>所在的位置加入<code>$PATH</code>变量中。</p>
<p>如果你使用的是默认的安装位置，使用你喜欢的编辑器，在你shell配置文件最后加入：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">CONDA_PATH=<span class="variable">$HOME</span>/miniconda3</span><br><span class="line"><span class="comment"># >>> conda initialize >>></span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by 'conda init' !!</span></span><br><span class="line">__conda_setup=<span class="string">"<span class="variable">$('$CONDA_PATH/bin/conda' 'shell.bash' 'hook' 2> /dev/null)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$__conda_setup</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$CONDA_PATH</span>/etc/profile.d/conda.sh"</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">"<span class="variable">$CONDA_PATH</span>/etc/profile.d/conda.sh"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$CONDA_PATH</span>/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># <<< conda initialize <<<</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果你修改了安装位置，那么修改第一行<code>$CONDA_PATH</code>的值为你的安装位置即可。</p>
<p>如果是使用pacman/yay安装的，安装路径可能是在<code>/opt/anaconda/bin</code>，检查一下路径的正确性然后修改<code>$CONDA_PATH</code>的值即可。</p>
<h2 id="ubuntu安装conda" class="heading-control"><a class="heading-anchor" href="#ubuntu安装conda" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#ubuntu安装conda"></a> Ubuntu安装Conda</h2>
<p>只需要：</p>
<p><strong>Linux 64-bits</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">bash <(curl -s -S -L <span class="string">"https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Linux 32-bits</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">bash <(curl -s -S -L <span class="string">"https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86.sh"</span>)</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Software</tag>
        <tag>Manjaro</tag>
        <tag>Conda</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】LaTeX中不能显示Adobe中文字体</title>
    <url>/2019/11/latex-cannot-display-adobe-font/</url>
    <content><![CDATA[<html><head></head><body><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/11/2019-11-20-latex-cannot-display-adobe-font-01.png!on_blog" alt></p>
<p>快毕业了，准备用LaTeX写论文，但LaTeX对于中文的支持并不是很好，在配置的过程中碰到了不少问题。<br>
发行版是TeX Live 2019，参考复旦大学论文模板<a href="https://ctan.math.illinois.edu/macros/latex/contrib/fduthesis/fduthesis.pdf" target="_blank" rel="noopener">fduthesis</a>下载了Adobe的四种字体<code>宋体</code>、<code>黑体</code>、<code>仿宋</code>和<code>楷体</code>，足以用来应对绝大多数的中文论文。<br>
但在设置好默认字体并成功编译后，却发现显示的是一片空白，尝试使用纯英文，同样无法显示。</p>
<a id="more"></a>
<p>LaTeX是一种基于TeX的排版系统，常用于撰写学术论文，可以把它看做命令行/代码块版的Word，需要一定的学习成本，但熟练之后效率远超Word。</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td><strong>Manjaro Linux</strong></td>
</tr>
<tr>
<td>TeX发行版</td>
<td><strong>TeX Live 2019</strong></td>
</tr>
<tr>
<td>TeX编辑器</td>
<td><strong>TeXStudio</strong></td>
</tr>
</tbody>
</table>
<p>因为我的主力系统是Manjaro Linux，没法获得CTEX的加持，否则倒是能省下不少功夫。<strong>如果你的系统是Windows，且不愿意过多折腾，建议直接使用<a href="http://www.ctex.org/CTeX" target="_blank" rel="noopener">CTEX</a>。</strong></p>
<h2 id="故障分析" class="heading-control"><a class="heading-anchor" href="#故障分析" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#故障分析"></a> 故障分析</h2>
<p>Linux下使用TeX Live编译输出PDF时，编译器不报错，但Adobe Font无法正常显示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">%!TEX program = xelatex</span><br><span class="line">\documentclass[12pt,a4paper]{article}</span><br><span class="line">\usepackage{fontspec,xunicode, xltxtra}</span><br><span class="line">\usepackage{xeCJK}</span><br><span class="line">\defaultfontfeatures{Mapping=tex-text}</span><br><span class="line">\setCJKmainfont{Adobe Song Std}</span><br><span class="line">\setmainfont{Source Han Serif}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line">	This is a test document, we use Source Han Serif font for English. \\</span><br><span class="line">	这是一个测试字体的文档，中文使用Adobe宋体。</span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure>
<p>如下图所示：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/11/2019-11-20-latex-cannot-display-adobe-font-02.jpg!on_blog" alt></p>
<h2 id="解决方法" class="heading-control"><a class="heading-anchor" href="#解决方法" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2>
<p>检查之后发现是内置的PDF渲染程序不支持Adobe Fonts，补齐相关依赖即可。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo apt-get install poppler-data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Manjaro</span></span><br><span class="line">sudo pacman -S poppler-data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他发行版请自行修改安装命令</span></span><br></pre></td></tr></tbody></table></figure>
<p>解决后显示结果如下图所示：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/11/2019-11-20-latex-cannot-display-adobe-font-03.png!on_blog" alt></p>
<h2 id="引用" class="heading-control"><a class="heading-anchor" href="#引用" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<ol>
<li><a href="https://forum.ubuntu.org.cn/viewtopic.php?t=274815" target="_blank" rel="noopener">latex 生成的 pdf 中 Adobe中文字体不能显示 - Ubuntu中文论坛</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Poppler" target="_blank" rel="noopener">Poppler - 维基百科，自由的百科全书</a></li>
</ol>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Software</tag>
        <tag>Manjaro</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX快速指南】（一）安装与配置中文环境</title>
    <url>/2019/11/latex-tutorial-01/</url>
    <content><![CDATA[<html><head></head><body><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/11/2019-11-20-latex-tutorial-01-01.png!on_blog" alt></p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>LaTeX（/ˈlɑːtɛx/，常被读作/ˈlɑːtɛk/或/ˈleɪtɛk/，写作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>），是一种基于TeX的排版系统，由美国计算机科学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学、物理文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。</p>
<p>——维基百科<em><a href="https://zh.wikipedia.org/wiki/LaTeX" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/LaTeX</a></em></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<a id="more"></a>
<p>相比于常见的Word和WPS等所见即所得的文字处理软件，LaTeX更像是一个极客手中的玩具，许多人想要上手却因为它的学习曲线陡峭望而却步，事实上「会用」却并不难。这篇入门教程的初衷便是提供一个简洁明了的上手教程，降低入门难度。如果有使用Markdown的经验，那么LaTeX会让你有一种熟悉感。</p>
<p><strong>本人能力有限，水平一般，错漏难免，欢迎指正。</strong></p>
<h2 id="安装latex环境" class="heading-control"><a class="heading-anchor" href="#安装latex环境" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装latex环境"></a> 安装LaTeX环境</h2>
<p>安装LaTeX需要两步：</p>
<ol>
<li>
<p>安装TeX发行版：</p>
<table>
<thead>
<tr>
<th>Platform</th>
<th>TeX Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td><a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">TeX Live</a>, <a href="http://www.ctex.org/HomePage" target="_blank" rel="noopener">CTeX</a>, <a href="https://mixtex.org" target="_blank" rel="noopener">MiKTeX</a></td>
</tr>
<tr>
<td>Linux</td>
<td><a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">TeX Live</a></td>
</tr>
<tr>
<td>macOS</td>
<td><a href="https://tug.org/mactex/" target="_blank" rel="noopener">MacTeX</a>, <a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">TeX Live</a></td>
</tr>
</tbody>
</table>
<p>其中TeX Live是唯一支持全平台的发行版，Linux和Windows下都建议使用TeX Live，一键式安装，方便快捷，功能完善，少有bug。官网下载速度较慢，下附TeX Live的镜像下载地址。</p>
<blockquote>
<p>感谢TUNA协会对开源社区的支持！</p>
<p>TeX Live 2019 下载地址：</p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2019-20190410.iso" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2019-20190410.iso</a></p>
</blockquote>
<p>下载后解压，双击<code>install-tl-windows.bat</code>后在GUI里点击安装即可。</p>
</li>
<li>
<p>安装TeX编辑器：<br>
TeX发行版和TeX编辑器的关系可以类比浏览器和Sublime/VSCode等编辑器的关系，浏览器负责对网页文件进行解析和渲染，VSCode则是用来编辑网页文件。后者不是必需的（甚至可以只用notepad），但一个好的编辑器可以极大地提升编辑体验和简化排版过程，推荐使用TeXStudio，另TeXLive自带了TeXworks，也可以直接使用。</p>
<blockquote>
<p>TeXStudio下载地址：</p>
<p><a href="http://texstudio.sourceforge.net/#download" target="_blank" rel="noopener">http://texstudio.sourceforge.net/#download</a></p>
</blockquote>
<p>选择与操作系统对应版本的安装包即可。</p>
</li>
</ol>
<h2 id="latex中文支持" class="heading-control"><a class="heading-anchor" href="#latex中文支持" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#latex中文支持"></a> LaTeX中文支持</h2>
<p>LaTeX开发之初并未考虑到中文排版的需求，原生不支持中文输入，为此一群大佬开发了CTeX，虽然在三年前便停止了更新，但对于初学者而言，它仍是开箱即用的不二选择。</p>
<p>如果有自定义字体的需求，则可以使用xeCJK。</p>
<p>打开TeXStudio后使用<code>Ctrl+N</code>新建一个tex文件，键入：</p>
<div class="tabs" id="tex_code"><ul class="nav-tabs"><li class="tab active"><a href="#tex_code-1">ctex</a></li><li class="tab"><a href="#tex_code-2">xelatex</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tex_code-1"><figure class="highlight tex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">% 文章类型</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{article}</span></span></span><br><span class="line"><span class="comment">% 导入包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{ctex}</span></span></span><br><span class="line"><span class="comment">% --------------------------------------- %</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 文章信息</span></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">{ctex+xelatex中文支持}</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">{十一}</span></span></span><br><span class="line"><span class="tag">\<span class="name">date</span><span class="string">{\today}</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 文章内容</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line"><span class="tag">\<span class="name">maketitle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 摘要</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{abstract}</span></span></span><br><span class="line">	这是一个测试用的摘要. <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	This is a abstract for test.</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{abstract}</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">{节1}</span></span></span><br><span class="line">这是一个测试用的节</span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">{节1.1}</span></span></span><br><span class="line">这是一个测试用的小节</span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">{节1.2}</span></span></span><br><span class="line">这是一个测试用的小节</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="tex_code-2"><figure class="highlight tex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">% 文章类型</span></span><br><span class="line"><span class="comment">% 文章类型</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{article}</span></span></span><br><span class="line"><span class="comment">% 导入包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{fontspec, xunicode, xltxtra}</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">[slantfont,boldfont]</span><span class="string">{xeCJK}</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{lmodern}</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 字体映射</span></span><br><span class="line"><span class="tag">\<span class="name">defaultfontfeatures</span><span class="string">{Mapping=tex-text}</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 中文缩进</span></span><br><span class="line"><span class="tag">\<span class="name">XeTeXlinebreaklocale</span></span> "zh"</span><br><span class="line"><span class="tag">\<span class="name">XeTeXlinebreakskip</span> = <span class="number">0pt</span></span> plus 1pt minus 0.1pt</span><br><span class="line"></span><br><span class="line"><span class="comment">% 中文字体设置</span></span><br><span class="line"><span class="comment">% 这里字体可以自行替换，对应的分别是全局字体、无衬线字体和等宽字体</span></span><br><span class="line"><span class="comment">% 但要确保是系统中已有的字体</span></span><br><span class="line"><span class="tag">\<span class="name">setCJKmainfont</span><span class="string">{宋体}</span></span></span><br><span class="line"><span class="tag">\<span class="name">setCJKsansfont</span><span class="string">{微软雅黑}</span></span></span><br><span class="line"><span class="tag">\<span class="name">setCJKmonofont</span><span class="string">{仿宋}</span></span></span><br><span class="line"><span class="comment">%\setCJKmainfont{Adobe Song Std}</span></span><br><span class="line"><span class="comment">%\setCJKsansfont{Adobe Heiti Std}</span></span><br><span class="line"><span class="comment">%\setCJKmonofont{Adobe Fangsong Std}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 文章信息</span></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">{ctex+xelatex中文支持}</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">{十一}</span></span></span><br><span class="line"><span class="tag">\<span class="name">date</span><span class="string">{\today}</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 文章内容</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line"><span class="tag">\<span class="name">maketitle</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 摘要</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{abstract}</span></span></span><br><span class="line">	这是一个测试用的摘要. <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	This is a abstract for test.</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{abstract}</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">{节1}</span></span></span><br><span class="line">这是一个测试用的节</span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">{节1.1}</span></span></span><br><span class="line">这是一个测试用的小节</span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">{节1.2}</span></span></span><br><span class="line">这是一个测试用的小节</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></figure></div></div></div>
<p>差别只在于开始的几行代码，具体实现上可以任意套用其中的一种，然后点击菜单栏上的双绿色箭头（或F5）进行编译并显示即可，显示效果如下图所示：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/11/2019-11-20-latex-tutorial-01-02.png!on_blog" alt></p>
<h2 id="q-a" class="heading-control"><a class="heading-anchor" href="#q-a" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#q-a"></a> Q & A</h2>
<div class="note danger">
            <p><strong>Fatal Package fontspec Error</strong></p><p>Question：代码提示<code>Fatal Package fontspec Error: The fontspec package requires either XeTeX or(fontspec) LuaTeX. \msg_fatal:nn {fontspec} {cannot-use-pdftex}</code>，如下：</p><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/11/2019-11-20-latex-tutorial-01-03.png!on_blog" alt></p><p>Answer：<strong><code>fontspec</code>或<code>ctex</code>均只能使用xelatex作为编译命令，需要替换编译引擎为<code>XeLaTeX</code>，TeXStudio在<code>Option > Configure TeXStudio... > Build > Default Compiler</code>处设置，TeXworks在菜单栏处可以直接选择。</strong></p>
          </div></body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】大数加法</title>
    <url>/2020/04/add-two-big-numbers/</url>
    <content><![CDATA[<html><head></head><body><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2020/04/2020-04-add-two-big-numbers-00.png!on_blog" alt></p>
<p>大数加法即能够对超长位数的数字进行相加，比如一个100位数和一个80位数的数字相加。</p>
<p>在这种情况下，数的大小已经超出了基本类型（int,long,double,float）能够表示的范围，直接加减只能得到错误的结果，想要得到正确的结果就需要使用其他数据结构存储这些数字，同时构建相应的相加函数，这里应该想到可以使用占用空间可选的字符串类型。</p>
<a id="more"></a>
<h2 id="问题抽象" class="heading-control"><a class="heading-anchor" href="#问题抽象" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#问题抽象"></a> 问题抽象</h2>
<p>输入为(M,N):</p>
<ul>
<li>M: 字符串<code>string</code>存储的10进制整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></li>
<li>N: 字符串<code>string</code>存储的10进制整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></li>
</ul>
<p>输出为S:</p>
<ul>
<li>S: 字符串<code>string</code>存储的10进制大数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></li>
</ul>
<h2 id="数学原理" class="heading-control"><a class="heading-anchor" href="#数学原理" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#数学原理"></a> 数学原理</h2>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2020/04/2020-04-add-two-big-numbers-01.gif!on_blog" alt></p>
<p>写出计算一般数加法的步骤，如上图。可以看到，每一次循环涉及到两个加数当前位<code>a</code>,<code>b</code>、进位<code>carry</code>和结果位<code>result</code>，关系如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">carry = (a + b) // 10</span><br><span class="line">result = (a + b) % 10</span><br></pre></td></tr></tbody></table></figure>
<p>循环至两个数结束，若其中一个数长度小于另外一个数，则该数当前位使用0进行计算。</p>
<h2 id="代码实现" class="heading-control"><a class="heading-anchor" href="#代码实现" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p>这里给出C++的算法实现，使用了大量内置的STL，如不能使用STL库可自行实现相关类型。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020-03-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"algorithm"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add two big decimal numbers</span></span><br><span class="line"><span class="comment"> * @param a string of a big number</span></span><br><span class="line"><span class="comment"> * @param b string of a big number</span></span><br><span class="line"><span class="comment"> * @return string of the result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">AddTwoNumbers</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> x, y, sum, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> result;</span><br><span class="line">    <span class="keyword">auto</span> iter_a = a.rbegin(), iter_b = b.rbegin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iter_a != a.rend() || iter_b != b.rend()) {</span><br><span class="line">        <span class="comment">// 其中一个数长度小于另外一个数，则遍历该数不存在的高位时，用0替代</span></span><br><span class="line">        x = iter_a != a.rend() ? *iter_a - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        y = iter_b != b.rend() ? *iter_b - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sum = x + y + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        result += <span class="keyword">char</span>(sum % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 遍历到最后一位时，迭代器不再移动</span></span><br><span class="line">        <span class="keyword">if</span> (iter_a != a.rend()) {</span><br><span class="line">            iter_a++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (iter_b != b.rend()) {</span><br><span class="line">            iter_b++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最高位存在进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) {</span><br><span class="line">        result += <span class="keyword">char</span>(carry + <span class="string">'0'</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    reverse(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里的<code>string</code>类型完全可以使用<code>char*</code>替代，可以尝试使用C进行实现。</p>
</body></html>]]></content>
      <categories>
        <category>问题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>大数问题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】美团笔试解析(待续)</title>
    <url>/2020/04/meituan-interview/</url>
    <content><![CDATA[<html><head></head><body><p>五题分别为：</p>
<ol>
<li>已知当前星期，时，分，求指定分钟前的星期，时，分。（日期问题）</li>
<li>有编号1-n的选手，给定出发排列顺序和到达排列顺序，只要存在一个人X，出发时X在Y前，到达时X在Y后，那么Y会受到嘉奖。求能受到嘉奖的总人数。（逆序对）</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></munder><mo stretchy="false">⌊</mo><mfrac><mi>x</mi><msup><mi>k</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">f(x)=\sum\limits_{i=1}\lfloor{\frac{x}{k^{i-1}}}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.727674em;vertical-align:-0.977669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.750005em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.977669em;"><span></span></span></span></span></span><span class="mopen">⌊</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7570857142857143em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌋</span></span></span></span>，给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">f(x)=n,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，求出令该式成立的最小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>值。</li>
<li>给定4个顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo separator="true">,</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S,A,B,C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>，任意两个顶点之间均有一条边，从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>点出发，经过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>步最终到达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>点的路径条数。（图论）</li>
<li>给定一组字符串，三种操作：插入/删除编号为x的字符串，求指定字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>和输入的字符串集合的匹配总次数。（字符串）</li>
</ol>
<a id="more"></a>
<h2 id="日期问题" class="heading-control"><a class="heading-anchor" href="#日期问题" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#日期问题"></a> 日期问题</h2>
<blockquote>
<p>已知当前星期，时，分，求指定分钟前的星期，时，分。（日期问题）</p>
<p>注：规定周二00:01前1分钟为周二00:00，周一23:59后1分钟为周二00:00.</p>
<p>输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">03:20</span><br><span class="line">180</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">00:20</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<details>
<summary>点击展开代码</summary>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file 05_DateTranslate.cpp</span></span><br><span class="line"><span class="comment"> * @author leslie</span></span><br><span class="line"><span class="comment"> * @date 2020-04-12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __05_DateTranslate_MAIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __05_DateTranslate_MAIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> d, h, m;</span><br><span class="line">    <span class="keyword">int</span> minutes, now, before;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> per_minute = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> per_hour = <span class="number">60</span> * per_minute;</span><br><span class="line">    <span class="keyword">int</span> per_day = <span class="number">24</span> * per_hour;</span><br><span class="line">    <span class="keyword">int</span> per_week = <span class="number">7</span> * per_day;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Input day and time now */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d:%d"</span>, &h, &m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &minutes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The starting point is every Monday at 0:00.</span></span><br><span class="line"><span class="comment">     * Minutes longer than a week are meaningless.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    minutes %= per_week;</span><br><span class="line">    now = d * per_day + h * per_hour + m * per_minute;</span><br><span class="line">    before = now - minutes;</span><br><span class="line">    before = before < per_day ? before + per_week : before;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output day and time before n minutes */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t%02d:%02d"</span>, (before / per_day) % <span class="number">7</span>, (before / per_hour) % <span class="number">24</span>, (before / per_minute) % <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>
</body></html>]]></content>
      <categories>
        <category>问题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】PyTorch构建自己的数据集</title>
    <url>/2019/12/pytorch-tutorial-01/</url>
    <content><![CDATA[<html><head></head><body><p>Python和MATLAB是机器学习最常用的两种开发工具，相比于MATLAB，Python的优势在于其免费使用以及开源，普通学生难以负担MATLAB的昂贵费用。机器学习的快速发展，推动了各种机器学习框架的出现，常见的机器学习框架如<code>TensorFlow</code>（Google）、<code>PyTorch/Torch</code>（Facebook）、<code>Caffe</code>（UC Berkeley）等。</p>
<p>PyTorch内置了诸如MNIST、cifar10等在内的一系列数据集，简单的几行代码就可以调用：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">'../data'</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                    transform=transforms.Compose([</span><br><span class="line">                        transforms.ToTensor(),</span><br><span class="line">                        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                    ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">'../data'</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">    ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>那么如何自定义数据集呢？</p>
<a id="more"></a>
<p>对PyTorch没有一点了解的可以先看这篇官方教程：<a href="https://pytorch.apachecn.org/" target="_blank" rel="noopener">Introduction · Pytorch 中文文档</a></p>
<hr>
<h2 id="摘要" class="heading-control"><a class="heading-anchor" href="#摘要" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<p>PyTorch内置抽象类<code>torch.utils.data.Dataset</code>，定义自己的数据集时，只需要继承该类，并重写其中的<code>__len__</code>和<code>__getitem__</code>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dataset</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""An abstract class representing a Dataset.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    All other datasets should subclass it. All subclasses should override</span></span><br><span class="line"><span class="string">    ``__len__``, that provides the size of the dataset, and ``__getitem__``,</span></span><br><span class="line"><span class="string">    supporting integer indexing in range from 0 to len(self) exclusive.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ConcatDataset([self, other])</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实现" class="heading-control"><a class="heading-anchor" href="#实现" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2>
<p><strong>切分数据集</strong></p>
<p>首先准备好自己的数据集，将测试集和训练集分别置于<code>data/train</code>和<code>data/test</code>中，组织文件结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── test</span><br><span class="line">│   │   ├── 1.jpg</span><br><span class="line">│   │   ├── 2.jpg</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   ├── test.txt</span><br><span class="line">│   ├── train</span><br><span class="line">│   │   ├── 1.jpg</span><br><span class="line">│   │   ├── 2.jpg</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── train.txt</span><br><span class="line">└── main.py</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>train.txt</code>和<code>test.txt</code>中存放标签：</p>
<figure class="highlight plain"><figcaption><span>train.txt</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">./data/train/1.jpg   1</span><br><span class="line">./data/train/2.jpg   1</span><br><span class="line">./data/train/3.jpg   2</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><figcaption><span>test.txt</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">./data/test/1.jpg   1</span><br><span class="line">./data/test/2.jpg   1</span><br><span class="line">./data/test/3.jpg   2</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p><strong>重写抽象类</strong></p>
<table>
<thead>
<tr>
<th>method</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__init__</code></td>
<td>初始化成员变量，读取txt文件中的图片路径、标签等信息</td>
</tr>
<tr>
<td><code>__getitem__</code></td>
<td>读取单个样本数据及标签</td>
</tr>
<tr>
<td><code>__len__</code></td>
<td>返回数据集大小</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, txt_path, transform=None)</span>:</span></span><br><span class="line">        self.txt_path = txt_path</span><br><span class="line"></span><br><span class="line">        imgs = []</span><br><span class="line">        <span class="keyword">with</span> open(self.txt_path, <span class="string">'r'</span>) <span class="keyword">as</span> dp:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> dp.readlines():</span><br><span class="line">                line = line.rstrip()</span><br><span class="line">                words = line.split()</span><br><span class="line">                imgs.append((words[<span class="number">0</span>], int(words[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">        self.imgs = imgs</span><br><span class="line">        self.transform = transform</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        fn, label = self.imgs[index]</span><br><span class="line">        img = Image.open(fn)</span><br><span class="line">        img = np.array(img)</span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.imgs)</span><br></pre></td></tr></tbody></table></figure>
<p>至此，一个简单的自定义数据集制作完成，调用方法与内置的数据集一般无二：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transform = transforms.ToTensors()</span><br><span class="line">train_path = <span class="string">r'./data/train.txt'</span></span><br><span class="line">test_path = <span class="string">r'./data/test.txt'</span></span><br><span class="line">train_data = MyDataset(train_path, transform)</span><br><span class="line">test_data = MyDataset(test_path, transform)</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size,</span><br><span class="line">    shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size,</span><br><span class="line">    shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="demo" class="heading-control"><a class="heading-anchor" href="#demo" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#demo"></a> demo</h2>
<a class="btn" href="/404.html">
            <i class="fa fa-"></i>Download demo.zip
          </a></body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】大数任意进制转换</title>
    <url>/2020/03/big-number-base-convert/</url>
    <content><![CDATA[<html><head></head><body><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2020/03/2020-03-big-number-base-convert-00.jpg!on_blog" alt></p>
<p>写算法题的时候经常会碰到一些大数相关的问题，比如大数乘法、大数加法等等，乘法和加法的原理基本上都比较符合正常的思维模式，因为加法和乘法的原理相对清晰，模拟数学计算步骤可以方便地分离，并转换为代码。</p>
<p>相对于常见的加法和乘法，进制转换出现的频率低一些，但同样是一个十分值得探讨的问题，并且难度较之加法和乘法更高。</p>
<a id="more"></a>
<h2 id="问题抽象" class="heading-control"><a class="heading-anchor" href="#问题抽象" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#问题抽象"></a> 问题抽象</h2>
<p>输入为(M, m, n):</p>
<ul>
<li>M: m进制整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">M_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，用字符串类型<code>string</code>储存</li>
<li>m: 大数基数m</li>
<li>n: 大数目的基数n</li>
</ul>
<p>输出为N：</p>
<ul>
<li>N: n进制整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">N_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，用字符串类型<code>string</code>储存</li>
</ul>
<h2 id="数学原理" class="heading-control"><a class="heading-anchor" href="#数学原理" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#数学原理"></a> 数学原理</h2>
<p>m进制转换成n进制，通常采用的是「模n取余法」，一般数进制转换的方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># num为输入数</span></span><br><span class="line">result = []</span><br><span class="line">temp = num</span><br><span class="line"><span class="keyword">while</span> temp > <span class="number">0</span>:</span><br><span class="line">    reminder = temp % to_base</span><br><span class="line">    quotient = temp // to_base</span><br><span class="line">    result.append(reminder)</span><br><span class="line">    temp = quotient</span><br><span class="line">   </span><br><span class="line">reverse(result)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>eg. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn><mo>→</mo><mo stretchy="false">(</mo><mn>11110</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">30\to(11110)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>30 / 2 = 15, 0<br>
15 / 2 = 7, 1<br>
7 / 2 = 3, 1<br>
3 / 2 = 1, 1<br>
1 / 2 = 0, 1</p>
</blockquote>
<p>第一次的商被用作第二次的除数，<strong>循环直至商为0</strong>，先余为低位，后余为高位，转换后的数为余数组的逆序。</p>
<p>可以想象，大数转换步骤同样如此。</p>
<p>问题只在于大数的<strong>整除</strong>和<strong>取余</strong>，这里直接将算法解释如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">quotient = []</span><br><span class="line">temp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> big_num:		<span class="comment"># 从大数中取位，取至最后一位循环停止</span></span><br><span class="line">    temp *= src_base    <span class="comment"># 余数乘以原基数</span></span><br><span class="line">    temp += i           <span class="comment"># 并加上当前位</span></span><br><span class="line">    <span class="keyword">if</span> temp < to_base:	<span class="comment"># 如果该数小于目标基数，商位上0</span></span><br><span class="line">        quotient.append(<span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>				<span class="comment"># 如果该数大于目标基数，上商，余数留给下一次运算</span></span><br><span class="line">        quotient.append(temp / to_base)</span><br><span class="line">        temp %= to_base</span><br><span class="line">        </span><br><span class="line">reminder = temp</span><br><span class="line">quotient = remove_front_zero(quotient)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>eg. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>11110</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>→</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">(11110)_2\to 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>当前位</th>
<th>运算</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(0 * 2 + 1) / 10 = 0, 1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>(1 * 2 + 1) / 10 = 0, 3</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>(3 * 2 + 1) / 10 = 0, 7</td>
<td>0</td>
<td>7</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>(7 * 2 + 1) / 10 = 1, 5</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>(5 * 2 + 0) / 10 = 1, 1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>故<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>11110</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mi mathvariant="normal">/</mi><mn>10</mn><mo>=</mo><mo stretchy="false">(</mo><mn>00011</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>11</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(11110)_2/10=(00011)_2=(11)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，余数为0</p>
<p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>11</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(11)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>用作下一次循环的运算数</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>当前位</th>
<th>运算</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(0 * 2 + 1) / 10 = 0, 0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>(1 * 2 + 1) / 10 = 0, 3</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>故<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>11</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mi mathvariant="normal">/</mi><mn>10</mn><mo>=</mo><mo stretchy="false">(</mo><mn>00</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(11)_2/10=(00)_2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，余数为3</p>
<p>循环结束，得到余数组<code>03</code>，逆序后得到进制转换后的数<code>30</code></p>
</blockquote>
<h2 id="代码实现" class="heading-control"><a class="heading-anchor" href="#代码实现" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p>这里给出C++的算法实现，使用了大量内置的STL，如不能使用STL库可自行实现相关类型。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"algorithm"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapping a n-base number to a int number</span></span><br><span class="line"><span class="comment"> * @param c the n-base number</span></span><br><span class="line"><span class="comment"> * return the int number</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">char</span> c)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (c >= <span class="string">'0'</span> && c <= <span class="string">'9'</span>) {</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c >= <span class="string">'a'</span> && c <= <span class="string">'z'</span>) {</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c >= <span class="string">'A'</span> && c <= <span class="string">'A'</span>) {</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">36</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a big num between different base.</span></span><br><span class="line"><span class="comment"> * @param a the string of big num</span></span><br><span class="line"><span class="comment"> * @param src_base the base of origin number,</span></span><br><span class="line"><span class="comment"> * @param to_base</span></span><br><span class="line"><span class="comment"> * @return the sring of big num in src_base</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">BaseConvert</span><span class="params">(<span class="built_in">string</span> a, <span class="keyword">int</span> src_base, <span class="keyword">int</span> to_base = <span class="number">10</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (src_base < <span class="number">2</span> || src_base > <span class="number">62</span> || to_base < <span class="number">2</span> || to_base > <span class="number">62</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span><<span class="keyword">const</span> <span class="keyword">char</span> *>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> num_alpha[] = <span class="string">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span><<span class="keyword">int</span>> number, quotient, result;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字母映射为数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &c : a) {</span><br><span class="line">        number.push_back(GetValue(c));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">auto</span> iter = number.begin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!number.empty()) {</span><br><span class="line">        <span class="comment">// 得到余数和商</span></span><br><span class="line">        <span class="keyword">while</span> (iter != number.end()) {</span><br><span class="line">            temp *= src_base;</span><br><span class="line">            temp += *iter++;</span><br><span class="line">            <span class="keyword">if</span> (temp < to_base) {</span><br><span class="line">                quotient.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                quotient.push_back(temp / to_base);</span><br><span class="line">                temp %= to_base;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 得到余数，存入result</span></span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清空商的前置0</span></span><br><span class="line">        <span class="keyword">auto</span> i = quotient.begin();</span><br><span class="line">        <span class="keyword">while</span> (*i == <span class="number">0</span> && i != quotient.end()) { i++; }</span><br><span class="line">        <span class="keyword">if</span> (i != quotient.begin()) {</span><br><span class="line">            quotient.erase(quotient.begin(), i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将商作为下一次的运算数，重置商数组和temp</span></span><br><span class="line">        number = quotient;</span><br><span class="line">        quotient.clear();</span><br><span class="line">        iter = number.begin();</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序余数位</span></span><br><span class="line">    reverse(result.begin(), result.end());</span><br><span class="line">    <span class="comment">// 将数字映射为字母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &i:result) {</span><br><span class="line">        s += num_alpha[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">cout</span> << BaseConvert(<span class="string">"11110"</span>, <span class="number">2</span>, <span class="number">10</span>) << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> << BaseConvert(<span class="string">"30"</span>, <span class="number">10</span>, <span class="number">2</span>) << <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>问题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>大数问题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS】捷径分享-删除最近图片</title>
    <url>/2020/04/ios-shortcut-share-01/</url>
    <content><![CDATA[<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2020/04/2020-04-ios-shortcut-share-01-00.jpg?x-oss-process=style/on_blog" alt="题图" />经常碰到需要多次截屏，将图片发送给朋友的情况，发送完后每次都要打开相册将其清理掉，次数一多就觉麻烦，把捷径的widget放到了通知中心，这样每次发送万之后只需要下滑打开通知中心，点击<strong>删除最近图片</strong>就可以方便地连续删除。</p>
<a id="more"></a>
<blockquote>
<p>捷径链接：<a class="btn" href="https://www.icloud.com/shortcuts/8446f75713b545b5b1ef69200798d1b2" target="_blank" rel="noopener">
            <i class="fa fa-"></i>点此下载捷径
          </a></p>
<p><a href="https://www.icloud.com/shortcuts/8446f75713b545b5b1ef69200798d1b2" target="_blank" rel="noopener">https://www.icloud.com/shortcuts/8446f75713b545b5b1ef69200798d1b2</a></p>
</blockquote>
<div align="center">
<div id="flowchart-0" class="flow-chart"></div>
</div>
<p>主要的点在于，删除最新图片<code>A</code>之后，重新获取的最新图片<code>A'</code>是否和A是同一张图片，如果是，证明删除<code>A</code>的操作被拒绝，循环终止，如果不是，则进行下一次循环，和其他删除图片的捷径相比少了一个选择是否继续的步骤，毕竟每次都选择还是挺烦的。<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
e=>end: 结束
wh=>inputoutput: 次数=10
getn1=>operation: 获取最新图片A
delp=>operation: 删除最新图片
getn2=>operation: 获取最新图片A'
c1=>condition: A=A'
subt=>operation: 次数-1
c2=>condition: 次数<=0?


st->wh->getn1->delp->getn2->c1
c1(yes)->e
c1(no)->subt(right)->c2
c2(yes)->e
c2(no)->wh()</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>快捷指令</tag>
        <tag>捷径</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】Typora使用图床自动上传</title>
    <url>/2020/04/typora-auto-upload-image/</url>
    <content><![CDATA[<html><head></head><body><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2020/04/2020-04-typora-auto-upload-image-title.png!on_blog" alt="题图"></p>
<p>Typora是一款非常优秀的Markdown编辑器，功能齐备，和其他编辑器最大的一点不同是，它吸收了Word所见即所得的特点，即时输入，实时预览。关于它的教程网上已經有很多了，尤其是<a href="https://sspai.com/search/post/typora" target="_blank" rel="noopener">少数派</a>上发布的几篇即全面又易懂的文章，在这里就不赘述它的用法了。</p>
<p>原本支持复制图片直接粘贴到编辑器中的它已经是十分能打了，年初时候它更是增加了自动上传的功能，提供了PicGo和自定义命令的接口。（PicGo是一款提供Windows、mac OS和<strong>Linux</strong>的跨平台图床工具）</p>
<a id="more"></a>
<h2 id="为啥要重新做轮子" class="heading-control"><a class="heading-anchor" href="#为啥要重新做轮子" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#为啥要重新做轮子"></a> 为啥要重新做轮子</h2>
<p>本着方（折）便（腾）的心思，用阿里云的Python接口自己写了一个十几行的工具，用来自动上传拖拽到Typora的图片，我的需求是自动根据当前日期创建文件夹，并将图片上传至对应的位置，如：2020年3月2日上传的图片<code>A.png</code>，我希望它能够呆在<code>2020/03/A.png</code>这个位置，PicGo暂时无法满足这个需求（只能自动修改<code>A.png</code>为<code>2020-03-A.png</code>）。</p>
<p>大致的思路就是读取外部配置，然后用阿里云的Python SDK上传。</p>
<p>代码开源在<a href="https://github.com/leslievan/typora-image-auto-upload" target="_blank" rel="noopener">Github</a>，熟悉编程/Python语言的可以自己编译打包，同样提供Windows和Linux编译好了的可执行文件，可以直接下载拿来用。</p>
<h2 id="相关设置" class="heading-control"><a class="heading-anchor" href="#相关设置" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#相关设置"></a> 相关设置</h2>
<p>下载二进制文件保存到本地，假设路径为<code>D:\typora-auto-upload</code>，修改配置文件<code>config.ini</code>，填入设置项，解释如下，详细的可以查看<a href="%5Bhttps://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E9%98%BF%E9%87%8C%E4%BA%91oss%5D(https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E9%98%BF%E9%87%8C%E4%BA%91oss)">PicGo配置文件</a>：</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code></td>
<td>选择<code>aliyun</code>或<code>tencent</code></td>
</tr>
<tr>
<td><code>endpoint</code></td>
<td>地域节点，如<code>oss-cn-beijing.aliyuncs.com</code></td>
</tr>
<tr>
<td><code>bucket</code></td>
<td>存储空间名</td>
</tr>
<tr>
<td><code>secret_id</code></td>
<td>密钥ID，阿里云应为<code>AccessID</code></td>
</tr>
<tr>
<td><code>secret_key</code></td>
<td>密钥Key，阿里云应为<code>AccessKey</code></td>
</tr>
<tr>
<td><code>path</code></td>
<td>自定义存储路径</td>
</tr>
</tbody>
</table>
<p>进入设置界面：</p>
<p>修改上传服务为<code>Custom Command</code></p>
<p>自定义命令为<code>D:\typora-auto-upload\autoupload.exe -f</code></p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2020/04/2020-04-typora-auto-upload-image.png" alt="设置"></p>
<p>修改完成后可以点击<code>验证图片上传选项</code>测试是否成功。</p>
<h2 id="结语" class="heading-control"><a class="heading-anchor" href="#结语" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2>
<p>做这个东西的源头是我个人的一点需求，所以选项很少，而且设计简陋，连界面都没有，但如果能帮到其他有类似需求的朋友，也是一种不错的体验。</p>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>【OS】HDU-OS-Lab2-Linux内核模块编程</title>
    <url>/2019/03/os-lab2/</url>
    <content><![CDATA[<html><head></head><body><p>Linux内核采用了整体结构，上一个实验体会了编译内核时间的冗长与繁杂，一步错就要重新编译，这虽然提高了效率，但同时也让后续的维护变得困难，在这个基础上，Linux内核引入了动态模块机制加以改进。</p>
<blockquote>
<p>视频教程地址：</p>
<p><a href="https://www.bilibili.com/video/av47412869/" target="_blank" rel="noopener">https://www.bilibili.com/video/av47412869/</a></p>
<p>源码地址：</p>
<p><a href="https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab2" target="_blank" rel="noopener">https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab2</a></p>
</blockquote>
<a id="more"></a>
<h1 id="实验内容" class="heading-control"><a class="heading-anchor" href="#实验内容" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h1>
<ul>
<li>设计一个模块，要求列出系统中所有内核线程的程序名、PID、进程状态、进程优先级、父进程的PID。</li>
<li>设计一个带参数的模块，其参数为某个进程的PID号，模块的功能是列出该进程的家族信息，包括父进程、兄弟进程和子进程的程序名、PID号及进程状态。</li>
<li>请根据自身情况，进一步阅读分析程序中用到的相关内核函数的源码实现。</li>
</ul>
<h1 id="代码设计" class="heading-control"><a class="heading-anchor" href="#代码设计" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#代码设计"></a> 代码设计</h1>
<p>实验分为两部分，一个让设计出一个不带参数的模块，功能是列出所有<strong>内核线程</strong>的程序名，称这个模块为<code>show_all_kernel_thread</code>，另一个要求是设计出一个带参数的模块，参数为某个进程的PID号，列出这个进程的父进程、子进程和兄弟进程，称这个模块为<code>show_task_family</code>。</p>
<h2 id="show_all_kernel_thread" class="heading-control"><a class="heading-anchor" href="#show_all_kernel_thread" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#show_all_kernel_thread"></a> show_all_kernel_thread</h2>
<p>可以根据功能写出大致的流程图：</p>
<div align="center">
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-26-2e80072e-1.svg" alt></p>
</div>
<p>结合代码进行分析：</p>
<div class="tabs" id="source_code1"><ul class="nav-tabs"><li class="tab active"><a href="#source_code1-1">show_all_kernel_thread.c</a></li><li class="tab"><a href="#source_code1-2">Makefile</a></li></ul><div class="tab-content"><div class="tab-pane active" id="source_code1-1"><figure class="highlight c"><figcaption><span>show_all_kernel_thread.c</span><a href="https://github.com/leslievan/Operator_System/blob/master/Operator_System_Lab2/Operator_System_Exp2_1/show_all_kernel_thread.c" target="_blank" rel="noopener">view raw___</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/init.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/kernel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/sched/signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/sched.h"</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块在加载的时候会运行init函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">show_all_kernel_thread_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 格式化输出头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    printk(<span class="string">"%-20s%-6s%-6s%-6s%-6s"</span>, <span class="string">"Name"</span>, <span class="string">"PID"</span>, <span class="string">"State"</span>, <span class="string">"Prio"</span>, <span class="string">"PPID"</span>);</span><br><span class="line">    printk(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for_each_process(p)的作用是从0开始遍历进程链表中的所有进程</span></span><br><span class="line">    for_each_process(p)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// p最开始指向进程链表中第一个进程，随着循环不断进行p也不断后移直至链表尾</span></span><br><span class="line">        <span class="keyword">if</span> (p->mm == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 打印进程p的相关信息</span></span><br><span class="line">            printk(<span class="string">"%-20s%-6d%-6d%-6d%-6d"</span>, p->comm, p->pid, p->state, p->prio,</span><br><span class="line">                   p->parent->pid);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块在加载的时候会运行exit函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">show_all_kernel_thread_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    printk(<span class="string">"[ShowAllKernelThread] Module Uninstalled."</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module_init(show_all_kernel_thread_init);</span><br><span class="line">module_exit(show_all_kernel_thread_exit);</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="source_code1-2"><figure class="highlight makefile"><figcaption><span>Makefile</span><a href="https://github.com/leslievan/Operator_System/blob/master/Operator_System_Lab2/Operator_System_Exp2_1/Makefile" target="_blank" rel="noopener">view raw___</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line">obj-m := show_all_kernel_thread.o</span><br><span class="line"><span class="comment"># kernel directory 源码所在文件夹，这里直接指向了系统文件中的内核源码，也可以将该路径改为你下载的源码路径</span></span><br><span class="line">KDIR := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="comment"># 当前路径</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></tbody></table></figure></div></div></div>
<p>这里用到了名为<code>for_each_process(p)</code>的宏定义，可以从<code>include/linux/sched/signal.h</code>中找到这个宏定义的具体代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_process(p) \</span></span><br><span class="line">	<span class="keyword">for</span> (p = &init_task ; (p = next_task(p)) != &init_task ; )</span><br></pre></td></tr></tbody></table></figure>
<p>这个宏定义较为简单这里不过多解释，有问题可在评论区一起探讨。</p>
<h2 id="show_task_family" class="heading-control"><a class="heading-anchor" href="#show_task_family" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#show_task_family"></a> show_task_family</h2>
<p>同样地，可以根据功能写出大致的流程图：</p>
<div align="center">
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-26-2e80072e-2.svg" alt></p>
</div>
<p>结合代码进行分析：</p>
<div class="tabs" id="source_code2"><ul class="nav-tabs"><li class="tab active"><a href="#source_code2-1">show_task_family.c</a></li><li class="tab"><a href="#source_code2-2">Makefile</a></li></ul><div class="tab-content"><div class="tab-pane active" id="source_code2-1"><figure class="highlight c"><figcaption><span>show_task_family.c</span><a href="https://github.com/leslievan/Operator_System/blob/master/Operator_System_Lab2/Operator_System_Exp2_2/show_task_family.c" target="_blank" rel="noopener">view raw___</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// created by 19-03-26</span></span><br><span class="line"><span class="comment">// Arcana</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/init.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/kernel.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/moduleparam.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/pid.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/list.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/sched.h"</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pid;</span><br><span class="line">module_param(pid, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">show_task_family_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">ppid</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pos</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *ptype[<span class="number">4</span>] = {<span class="string">"[I]"</span>, <span class="string">"[P]"</span>, <span class="string">"[S]"</span>, <span class="string">"[C]"</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过进程的PID号pid一步步找到进程的进程控制块p</span></span><br><span class="line">    ppid = find_get_pid(pid);</span><br><span class="line">    <span class="keyword">if</span> (ppid == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        printk(<span class="string">"[ShowTaskFamily] Error, PID not exists.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    p = pid_task(ppid, PIDTYPE_PID);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 格式化输出表头</span></span><br><span class="line">    printk(<span class="string">"%-10s%-20s%-6s%-6s\n"</span>, <span class="string">"Type"</span>, <span class="string">"Name"</span>, <span class="string">"PID"</span>, <span class="string">"State"</span>);</span><br><span class="line">    printk(<span class="string">"------------------------------------------\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Itself</span></span><br><span class="line">    <span class="comment">// 打印自身信息</span></span><br><span class="line">    printk(<span class="string">"%-10s%-20s%-6d%-6d\n"</span>, ptype[<span class="number">0</span>], p->comm, p->pid, p->state);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Parent</span></span><br><span class="line">    <span class="comment">// 打印父进程信息</span></span><br><span class="line">    printk(<span class="string">"%-10s%-20s%-6d%-6d\n"</span>, ptype[<span class="number">1</span>], p->real_parent->comm,</span><br><span class="line">           p->real_parent->pid, p->real_parent->state);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Siblings</span></span><br><span class="line">    <span class="comment">// 遍历父进程的子，即我的兄弟进程，输出信息</span></span><br><span class="line">    <span class="comment">// 「我」同样是父进程的子进程，所以当二者进程PID号一致时，跳过不输出</span></span><br><span class="line">    list_for_each_entry(pos, &(p->real_parent->children), sibling)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (pos->pid == pid)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        printk(<span class="string">"%-10s%-20s%-6d%-6d\n"</span>, ptype[<span class="number">2</span>], pos->comm, pos->pid,</span><br><span class="line">               pos->state);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Children</span></span><br><span class="line">    <span class="comment">// 遍历「我」的子进程，输出信息</span></span><br><span class="line">    list_for_each_entry(pos, &(p->children), sibling)</span><br><span class="line">    {</span><br><span class="line">        printk(<span class="string">"%-10s%-20s%-6d%-6d\n"</span>, ptype[<span class="number">3</span>], pos->comm, pos->pid,</span><br><span class="line">               pos->state);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">show_task_family_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    printk(<span class="string">"[ShowTaskFamily] Module Uninstalled.\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module_init(show_task_family_init);</span><br><span class="line">module_exit(show_task_family_exit);</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="source_code2-2"><figure class="highlight makefile"><figcaption><span>Makefile</span><a href="https://github.com/leslievan/Operator_System/blob/master/Operator_System_Lab2/Operator_System_Exp2_2/Makefile" target="_blank" rel="noopener">view raw___</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># created by 19-03-26</span></span><br><span class="line"><span class="comment"># Arcana</span></span><br><span class="line">obj-m := show_task_family.o</span><br><span class="line">KDIR := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></tbody></table></figure></div></div></div>
<p>这个模块中最复杂的部分是<code>list_for_each_entry</code>。它是位于<code>include/linux/list.h</code>中的一个宏定义：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct task_struct *pos;</span></span><br><span class="line"><span class="comment">    list_for_each_entry(pos, &pos->children, sibling);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member)				\</span></span><br><span class="line">    <span class="keyword">for</span> (pos = __container_of((head)->next, pos, member);		\</span><br><span class="line">	 &pos->member != (head);					\</span><br><span class="line">	 pos = __container_of(pos->member.next, pos, member))</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到，展开之后它是一个清晰的for循环，三个参数分别是<code>pos</code>、<code>head</code>和<code>member</code>，关于这个宏定义建议大家仔细阅读书本<code>7.3.4</code>。这是一个非常奇妙的操作，基于此它可以将任意一个结构体都附上链表的功能，只需要将一个叫做<code>list_head</code>的数据结构放在结构体中，这一部分理解起来可能稍微复杂，这里只讲解用法，有兴趣的同学可以自行研究。</p>
<p><code>pos</code>是数据项类型的指针，比如这里需要使用<code>task_struct</code>类型的数据，所以在上面的示例中，将<code>pos</code>声明为<code>task_struct *</code>类型.</p>
<p>剩下两个参数结合下图理解：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-26-2e80072e-3.svg" alt></p>
<p>这里的<code>*.children</code>和<code>*.sibling</code>均为<code>list_head *</code>类型的变量，是<code>task_struct</code>的一个成员，在这里，<code>parent.children.next</code>指向的是<code>children1.sibling</code>，而<code>children4.sibling.next</code>指向的是<code>parent.children</code>，它是一个双向循环链表，这里只标注出了<code>next</code>的一侧，隐去了<code>prev</code>的一侧。</p>
<p>第二个参数<code>head</code>是表头的地址，在这里就表示为<code>&parent.children</code>，第三个参数<code>member</code>指的是在链表中，<code>list_head *</code>的位置，可能会混淆的是，<code>task_struct</code>中的两个成员变量<code>children</code>和<code>sibling</code>都是<code>list_head *</code>类型，为什么选择<code>sibling</code>而不是<code>children</code>呢？我个人的理解是，<code>children</code>只是一个引子，代表一个参照物，真正进行中转的变量是<code>sibling</code>，才疏学浅，表达不太准确，有兴趣的同学可以自行查阅资料。</p>
<h1 id="编译-安装" class="heading-control"><a class="heading-anchor" href="#编译-安装" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#编译-安装"></a> 编译 & 安装</h1>
<p>模块编译的命令与第一个实验中内核编译的命令是一致的，实际上<code>make</code>命令能做的远不止编译内核和编译模块。</p>
<p>上面一共四个文件，分为两个文件夹储存，这里将文件夹命名为<code>A</code>和<code>B</code>，把<code>show_all_kernel_thread.c</code>和与之对应的<code>Makefile</code>文件放到<code>A</code>中，自然地，把<code>show_task_family.c</code>和与之对应的<code>Makefile</code>文件放到<code>B</code>中。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将A改为当前目录，开始编译</span></span><br><span class="line">cd A</span><br><span class="line">make</span><br></pre></td></tr></tbody></table></figure>
<p>编译成功之后你的A目录下应该有这些文件，同理你可以在B目录下进行同样的操作：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── modules.order</span><br><span class="line">├── Module.symvers</span><br><span class="line">├── show_all_kernel_thread.c</span><br><span class="line">├── show_all_kernel_thread.ko</span><br><span class="line">├── show_all_kernel_thread.mod.c</span><br><span class="line">├── show_all_kernel_thread.mod.o</span><br><span class="line">└── show_all_kernel_thread.o</span><br></pre></td></tr></tbody></table></figure>
<p>检验文件后，开始安装模块</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> without parameter</span></span><br><span class="line">sudo insmod show_all_kernel_thread.ko</span><br><span class="line"><span class="meta">#</span><span class="bash"> with parameter</span></span><br><span class="line">sudo insmod show_task_family pid=xxxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载（在整个文件结束之后</span></span><br><span class="line">sudo rmmod show_all_kernel_thread</span><br><span class="line">sudo rmmod show_task_family</span><br></pre></td></tr></tbody></table></figure>
<h1 id="测试" class="heading-control"><a class="heading-anchor" href="#测试" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#测试"></a> 测试</h1>
<p>前文提到，当模块被加载时，会运行<code>init</code>函数，在退出时，会运行<code>exit</code>函数。<code>printk</code>函数将输出打印到了日志中，可以使用<code>dmesg</code>命令查看系统日志，如果有遗留下的痕迹，且是正确答案，则代表测试成功。</p>
<p><code>show_all_kernel_thread</code>要求显示出所有内核线程，测试步骤可如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make && sudo insmod show_all_kernel_thread.ko</span><br><span class="line">dmesg</span><br></pre></td></tr></tbody></table></figure>
<p>开启另一个终端，输入<code>ps</code>命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></tbody></table></figure>
<p>此时会显示出所有线程，线程名带有<code>[]</code>的即为内核线程，稍微挑选一二能对上即可。</p>
<hr>
<p><code>show_task_family</code>要求显示出某一个进程的家族关系，测试步骤可如下：</p>
<p>使用<code>pstree</code>命令查看进程树：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">pstree -p</span><br></pre></td></tr></tbody></table></figure>
<p>选择一个既有兄弟进程又有子进程的进程（建议使用<code>systemd</code>，使用此进程作为测试，可以看到这个进程的PID。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make && sudo insmod show_task_family.ko pid=xxxx</span><br><span class="line">dmesg</span><br></pre></td></tr></tbody></table></figure>
<p>开启另一个终端，输入<code>pstree</code>命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">pstree -p xxxx</span><br></pre></td></tr></tbody></table></figure>
<p><code>xxxx</code>是刚刚选中的那个进程号。</p>
<p>对比进程树与系统日志中的记录，选择一二能对上即可。</p>
<h2 id="相关阅读" class="heading-control"><a class="heading-anchor" href="#相关阅读" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#相关阅读"></a> 相关阅读</h2>
<ul>
<li>
<a href="/2019/01/os-lab1/" title="【OS】HDU-OS-Lab1-Linux内核编译及添加系统调用">【OS】HDU-OS-Lab1-Linux内核编译及添加系统调用</a>
</li>
<li>
<a href="/2019/04/os-lab-3-2/" title="【OS】HDU-OS-Lab3-Linux进程管理（二）管道通信">【OS】HDU-OS-Lab3-Linux进程管理（二）管道通信</a>
</li>
<li>
<a href="/2019/04/os-lab-3-3/" title="【OS】HDU-OS-Lab3-Linux进程管理（三）进程通信">【OS】HDU-OS-Lab3-Linux进程管理（三）进程通信</a></li>
</ul>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】VMware Workstation中创建Ubuntu虚拟机</title>
    <url>/2019/03/vmware-create-vm/</url>
    <content><![CDATA[<html><head></head><body><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-0.png!on_blog" alt></p>
<p>简单描述如何使用VMware Workstation Pro创建一个新的虚拟机。</p>
<a id="more"></a>
<h1 id="准备工作" class="heading-control"><a class="heading-anchor" href="#准备工作" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1>
<p>在开始创建新的虚拟机之前，你需要在本机上安装VMware Workstation，并准备好相应的镜像。</p>
<p>关于安装VMware Workstation，你可以参考<a href="/2019/02/ubuntu-config-vmware/">这篇文章</a>。</p>
<p>至于镜像，你可以直接百度搜索官方网站进行下载，但不推荐这种方法，Linux发行版的网站服务器大多都在国外，因此下载速度会很慢，国内有许多镜像站可以用于下载镜像，如阿里的<a href="https://opsx.alibaba.com/" target="_blank" rel="noopener">OSPX</a>，清华的<a href="https://mirrors.tuna.tsinghua.edu.cn" target="_blank" rel="noopener">清华大学开源软件镜像站</a>等，这里提供两个网站的<code>Ubuntu 16.04 LTS</code>和<code>Ubuntu 18.04 LTS</code>的下载地址：</p>
<p><strong>OSPX</strong></p>
<ul>
<li><a href="https://mirrors.aliyun.com/ubuntu-releases/xenial/ubuntu-16.04.6-desktop-amd64.iso" target="_blank" rel="noopener">Ubuntu 16.04</a></li>
<li><a href="https://mirrors.aliyun.com/ubuntu-releases/releases/18.04.2/ubuntu-18.04.2-desktop-amd64.iso" target="_blank" rel="noopener">Ubuntu 18.04</a></li>
</ul>
<p><strong>清华大学开源软件镜像站</strong></p>
<ul>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/xenial/ubuntu-16.04.6-desktop-amd64.iso" target="_blank" rel="noopener">Ubuntu 16.04</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/bionic/ubuntu-18.04.2-desktop-amd64.iso" target="_blank" rel="noopener">Ubuntu 18.04</a></li>
</ul>
<p>到此，准备工作完成，你拥有了一台安装好<code>VMware Workstation</code>的电脑以及一个名为<code>ubuntu-xx.xx.x-desktop-amd64.iso</code>的镜像文件。</p>
<h1 id="创建步骤" class="heading-control"><a class="heading-anchor" href="#创建步骤" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#创建步骤"></a> 创建步骤</h1>
<p>对于诸如Ubuntu、Windows等一些常见的操作系统，VMware Workstation提供了简易安装的方式，免去一些安装步骤，降低用户使用难度，适合新手玩家。</p>
<h2 id="打开vmware" class="heading-control"><a class="heading-anchor" href="#打开vmware" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#打开vmware"></a> 打开VMware</h2>
<p>打开VMware，点击<code>Create a New Virtual Machine</code>（中文下应为创建新的虚拟机，之后不再提示）。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-1.png!on_blog" alt></p>
<h2 id="选择安装方式" class="heading-control"><a class="heading-anchor" href="#选择安装方式" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#选择安装方式"></a> 选择安装方式</h2>
<p>这里我们使用推荐的安装方式，选择<code>Typical</code>，点击<code>Next</code>。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-2.png!on_blog" alt></p>
<hr>
<p>这里有两种安装方法，<a href="#%E7%AE%80%E6%98%93%E5%AE%89%E8%A3%85">简易安装</a>以及<a href="#%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85">手动安装</a>，简易安装方便快捷，但安装过程中可能会出现一些玄学问题，手动安装稍显麻烦，但好在依据步骤则不会出现问题，而且某种程度上可以学到更多的东西。</p>
<h2 id="简易安装" class="heading-control"><a class="heading-anchor" href="#简易安装" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#简易安装"></a> 简易安装</h2>
<p>你可以先创建虚拟机，之后再选择镜像（第三项），类似于你买了电脑，但是里面并没有预先安装任何系统，这里我们选择第二项<code>Use ISO Image</code>，在创建虚拟机之后直接安装系统，点击<code>Browse</code>选择你刚刚下载的镜像文件，然后点击<code>Next</code>。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-3.png!on_blog" alt></p>
<h2 id="指定简易安装信息" class="heading-control"><a class="heading-anchor" href="#指定简易安装信息" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#指定简易安装信息"></a> 指定简易安装信息</h2>
<p>填写空着的四项内容，点击<code>Next</code>。</p>
<table>
<thead>
<tr>
<th>简易安装提示</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full name</td>
<td>所创建客户机的全名，可任意输入。</td>
</tr>
<tr>
<td>User name</td>
<td>用户名，用户标识符，表明你的身份，配合<code>Password</code>用于登陆Ubuntu。</td>
</tr>
<tr>
<td>Password</td>
<td>密码，即你创建用户的密码。</td>
</tr>
<tr>
<td>Confirm</td>
<td>验证密码，重新输入以上的密码。</td>
</tr>
</tbody>
</table>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-4.png!on_blog" alt></p>
<h2 id="指定虚拟机名称和文件位置" class="heading-control"><a class="heading-anchor" href="#指定虚拟机名称和文件位置" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#指定虚拟机名称和文件位置"></a> 指定虚拟机名称和文件位置</h2>
<p>这里的<code>Name</code>和<code>Location</code>都可以任意选择，我直接使用默认的配置，点击<code>Next</code>。</p>
<table>
<thead>
<tr>
<th>简易安装提示</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>虚拟机名称，可任意输入。</td>
</tr>
<tr>
<td>Location</td>
<td>虚拟机文件所在位置，尽量选择一个剩余容量大的磁盘。</td>
</tr>
</tbody>
</table>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-5.png!on_blog" alt></p>
<h2 id="为虚拟机指定磁盘容量" class="heading-control"><a class="heading-anchor" href="#为虚拟机指定磁盘容量" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#为虚拟机指定磁盘容量"></a> 为虚拟机指定磁盘容量</h2>
<p>注意容量是<code>Maximum disk size</code>而不是你一开始就分配这么多空间，所以你大可以分配一个大一点的空间，**千万别使用推荐配置中的20GB！**这里我直接给了100GB，基本上怎么折腾都足够了，如果你在这里直接选择了20GB，别急，也有补救措施，这篇文章会给你答案。</p>
<p>至于下面两个选项，一个是以单文件存储，一个是多文件存储，选择单文件存储意味着，最大容量100GB的内容都会存储在一个单独的文件中，而多文件存储则是每使用4GB空间就创建一个新的文件，即你用完100GB空间后，会生成25个文件，我并未比较过两种方式的优劣，但基本不影响我们使用系统，这里直接以默认的多文件存储方式安装。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-6.png!on_blog" alt></p>
<h2 id="自定义虚拟机硬件" class="heading-control"><a class="heading-anchor" href="#自定义虚拟机硬件" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#自定义虚拟机硬件"></a> 自定义虚拟机硬件</h2>
<p>在这里可以修改默认的硬件设置，包括内存分配、虚拟 CPU 数量、CD/DVD 和软盘驱动器设置以及网络连接类型。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-7.png!on_blog" alt></p>
<p>点击<code>Customize Hardware…</code>进行自定义，可能需要修改的地方有两个。</p>
<ul>
<li>内存（Memory）。如果物理机内存在8G以下，建议你只需要按照默认配置分配2G给虚拟机，如果物理机内存在8G及8G以上，则可以分配4G及4G以上的空间，至少需要留出1/2的最大内存以满足物理机运行需要（不会卡顿）。</li>
<li>处理器（Processors）。处理器影响多线程工作效率，默认为单核心单处理器，这里可以修改为双核心双处理器（2×2）。</li>
</ul>
<p>其他属性不建议新手玩家修改，修改完之后点击<code>Close</code>保存配置，返回主界面，然后点击<code>Finish</code>。</p>
<p>简易安装的步骤到这里就结束了，不过简易安装不一定适用于所有人，可能会出现一些小问题，如果有问题可以在最后留言。</p>
<h2 id="手动安装" class="heading-control"><a class="heading-anchor" href="#手动安装" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#手动安装"></a> 手动安装</h2>
<p>手动安装稍显麻烦，前面两个步骤<a href="#%E6%89%93%E5%BC%80VMware">打开VMware</a>和<a href="#%E9%80%89%E6%8B%A9%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F">选择安装方式</a>都和简易安装一样，在选择镜像时才出现差异，这里略去前两步，直接从第三步开始选择第三项<code>I will install the operating system later</code>而不是第二项<code>Use ISO image</code>，然后点击<code>Next</code>。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-8.png!on_blog" alt></p>
<h2 id="创建虚拟机" class="heading-control"><a class="heading-anchor" href="#创建虚拟机" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#创建虚拟机"></a> 创建虚拟机</h2>
<p>这一步根据你的镜像选择虚拟机类型，之前下载的镜像为<code>Ubuntu 16.04</code>或<code>Ubuntu 18.04</code>，均为64位的Linux发行版（Ubuntu同样提供32位，我们使用的是64位的），选择后点击<code>Next</code>。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-9.png!on_blog" alt></p>
<p>接下来的几个步骤同上面一样，<a href="#%E6%8C%87%E5%AE%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%8D%E7%A7%B0%E5%92%8C%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE">指定虚拟机名称和文件位置</a>-><a href="#%E4%B8%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E5%AE%9A%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F">为虚拟机指定磁盘容量</a>-><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A1%AC%E4%BB%B6">自定义虚拟机硬件</a>，然后点击<code>Finish</code>，完成创建。</p>
<h2 id="安装系统" class="heading-control"><a class="heading-anchor" href="#安装系统" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装系统"></a> 安装系统</h2>
<p>虚拟机创建完成后，会跳转到如下图所示的界面：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-10.png!on_blog" alt></p>
<p>双击箭头所示的<code>CD…</code>，在弹窗中选择<code>Use ISO image</code>，选择你想要安装的镜像：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-19.png!on_blog" alt></p>
<p>点击<code>Save</code>后，启动虚拟机：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-11.png!on_blog" alt></p>
<h3 id="选择语言" class="heading-control"><a class="heading-anchor" href="#选择语言" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#选择语言"></a> 选择语言</h3>
<p>如果镜像没有问题的话，VMware会自动打开镜像，提示选择语言，准备进行安装：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-12.png!on_blog" alt></p>
<h3 id="选择键盘布局" class="heading-control"><a class="heading-anchor" href="#选择键盘布局" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#选择键盘布局"></a> 选择键盘布局</h3>
<p>使用默认选项即可，直接<code>继续</code>。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-13.png!on_blog" alt></p>
<h3 id="选择安装方式-2" class="heading-control"><a class="heading-anchor" href="#选择安装方式-2" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#选择安装方式-2"></a> 选择安装方式</h3>
<p>最小安装省略了如LibreOffice之类的办公软件，基本上我们是不会用到的，最小安装可以极大地提升安装速度，推荐选择，当然玩家也可以自行斟酌，选择正常安装也是可以的。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-14.png!on_blog" alt></p>
<h3 id="选择安装类型" class="heading-control"><a class="heading-anchor" href="#选择安装类型" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#选择安装类型"></a> 选择安装类型</h3>
<p>直接选择第一项就可以了，这里的清除整个磁盘指的不是主机的磁盘，而是虚拟机的磁盘，所以不需要考虑，也可以自行尝试<code>其它选项</code>，点击<code>现在安装</code>：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-15.png!on_blog" alt></p>
<p>点击<code>继续</code>：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-16.png!on_blog" alt></p>
<h3 id="选择地区" class="heading-control"><a class="heading-anchor" href="#选择地区" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#选择地区"></a> 选择地区</h3>
<p>它会默认检测，如不需要特殊配置直接<code>继续</code>就行：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-17.png!on_blog" alt></p>
<h3 id="指定ubuntu安装信息" class="heading-control"><a class="heading-anchor" href="#指定ubuntu安装信息" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#指定ubuntu安装信息"></a> 指定Ubuntu安装信息</h3>
<p>这里参考<a href="#%E6%8C%87%E5%AE%9A%E7%AE%80%E6%98%93%E5%AE%89%E8%A3%85%E4%BF%A1%E6%81%AF">指定简易安装信息</a>。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-18.png!on_blog" alt></p>
<h3 id="重启系统" class="heading-control"><a class="heading-anchor" href="#重启系统" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#重启系统"></a> 重启系统</h3>
<p>点击<code>继续</code>后，如无特殊事件只需静静等待，直到出现以下界面，选择<code>现在重启</code>：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-03-05-7e1ef425-20.png!on_blog" alt></p>
<p>有时你可能需要根据提示，按下Enter自行重启。</p>
<h2 id="vmware-tools配置" class="heading-control"><a class="heading-anchor" href="#vmware-tools配置" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#vmware-tools配置"></a> VMware Tools配置</h2>
<p>参考另一篇文章：<a href="/2019/02/ubuntu-config-vmware/#%E5%AE%89%E8%A3%85vmware-tools">Ubuntu下配置VMware Workstation</a></p>
<hr>
<p>至此，安装完成，你可以开心地使用你的虚拟机了！</p>
</body></html>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Software</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>【OS】HDU-OS-Lab3-Linux进程管理（二）管道通信</title>
    <url>/2019/04/os-lab-3-2/</url>
    <content><![CDATA[<html><head></head><body><p>实验三的知识点是进程通信，进程通信的方式多种多样，既包括锁机制、信号量机制在内的低级通信方式，低级在于其交换的信息量少且效率较低，又包括共享服务器、消息传递系统、管道通信以及客户-服务器系统通信在内的高级通信方式，本实验是实验三的第二部分，介绍了管道通信方式的基本原理以及具体实现。</p>
<blockquote>
<p>源码地址：</p>
<p><a href="https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab3/Operator_System_Exp3_2" target="_blank" rel="noopener">https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab3/Operator_System_Exp3_2</a></p>
</blockquote>
<a id="more"></a>
<h2 id="基本介绍" class="heading-control"><a class="heading-anchor" href="#基本介绍" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#基本介绍"></a> 基本介绍</h2>
<p>管道是一个文件，用于连接两个进程以实现进程通信。管道是半双工的，即同一时间同一进程只能读取或者写入。管道又分为有名管道和无名管道两种，无名管道存在于高速缓存<code>cache</code>中，用于有亲缘关系的父子进程或兄弟进程之间的通信，有名管道存在于磁盘中，是看得见摸得着的<code>真实文件</code>，只要知道路径名就可以调用，所以它可以用于任意进程之间的通信。前面提到管道是一个文件，所以不论是有名管道还是无名管道，它们写入或读取的方式都是一样的——使用<code>write</code>进行写入，使用<code>read</code>进行读取。</p>
<h2 id="实验内容" class="heading-control"><a class="heading-anchor" href="#实验内容" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2>
<blockquote>
<p><strong>实现一个管道通信程序</strong></p>
<p>由父进程创建一个管道，然后再创建三个子进程，并由这三个子进程利用管道与父进程之间进行通信：子进程发送信息，父进程等三个子进程全部发完消息后再接收信息。通信的具体内容可根据自己的需要随意设计，要求能试验阻塞型读写过程中的各种情况，测试管道的默认大小，并且要求利用Posix信号量机制实现进程间对管道的互斥访问。运行程序，观察各种情况下，进程实际读写的字节数以及进程阻塞唤醒的情况。</p>
</blockquote>
<p>根据实验要求可知，这里直接选用无名管道即可，实验要求有：</p>
<ul>
<li>试验阻塞型读写过程中的各种情况</li>
<li>测试管道的默认大小</li>
<li>利用Posix信号量机制实现进程间对管道的互斥访问</li>
</ul>
<p>先放上能够实现这些功能的代码。</p>
<figure class="highlight c"><figcaption><span>main.c</span><a href="https://github.com/leslievan/Operator_System/raw/master/Operator_System_Lab3/Operator_System_Exp3_2/main.c" target="_blank" rel="noopener">view raw___</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @file        main.c</span></span><br><span class="line"><span class="comment"> * @author      Arcana</span></span><br><span class="line"><span class="comment"> * @date        2018.11.12</span></span><br><span class="line"><span class="comment"> * @brief       Children process communicate with parent by pipe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errno.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"semaphore.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/sem.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/wait.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_MAX_SIZE 8192</span></span><br><span class="line"><span class="comment">// 如果x为假，则报错，打印出错代码所在函数及行数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK(x)                                            \</span></span><br><span class="line">    <span class="keyword">do</span> {                                                    \</span><br><span class="line">        <span class="keyword">if</span> (!(x)) {                                         \</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s:%d: "</span>, __func__, __LINE__); \</span><br><span class="line">            perror(#x);                                     \</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);                                       \</span><br><span class="line">        }                                                   \</span><br><span class="line">    } <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create three children processes to test pipe communication.</span></span><br><span class="line"><span class="comment"> * @param argc Argument count.</span></span><br><span class="line"><span class="comment"> * @param argv Argument vector.</span></span><br><span class="line"><span class="comment"> * @return status code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>], pid, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_MAX_SIZE];</span><br><span class="line">    <span class="keyword">char</span> str[BUF_MAX_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建有名信号量，若不存在则创建，若存在则直接打开，默认值为0</span></span><br><span class="line">    <span class="keyword">sem_t</span> *write_mutex;</span><br><span class="line">    <span class="keyword">sem_t</span> *read_mutex1;</span><br><span class="line">    <span class="keyword">sem_t</span> *read_mutex2;</span><br><span class="line">    write_mutex = sem_open(<span class="string">"pipe_test_wm"</span>, O_CREAT | O_RDWR, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    read_mutex1 = sem_open(<span class="string">"pipe_test_rm_1"</span>, O_CREAT | O_RDWR, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    read_mutex2 = sem_open(<span class="string">"pipe_test_rm_2"</span>, O_CREAT | O_RDWR, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUF_MAX_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="number">0</span>, BUF_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道并检查操作是否成功</span></span><br><span class="line">    CHECK(pipe(pipefd) >= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一个子进程并检查操作是否成功</span></span><br><span class="line">    CHECK((pid = fork()) >= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个子进程，利用非阻塞写测试管道大小</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">1</span>], F_GETFL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 管道默认是阻塞写，通过`fcntl`设置成非阻塞写，在管道满无法继续写入时返回-EAGAIN，作为循环终止条件</span></span><br><span class="line">        fcntl(pipefd[<span class="number">1</span>], F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 写入管道</span></span><br><span class="line">        <span class="keyword">while</span> (!flag) {</span><br><span class="line">            n = <span class="built_in">write</span>(pipefd[<span class="number">1</span>], buf, BUF_MAX_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">-1</span>) {</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                count++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"children 1 write %dB\n"</span>, n);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"space = %dKB\n"</span>, (count * BUF_MAX_SIZE) / <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个子进程并检查操作是否成功</span></span><br><span class="line">    CHECK((pid = fork()) >= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        sem_wait(write_mutex);</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        n = <span class="built_in">write</span>(pipefd[<span class="number">1</span>], <span class="string">"This is the second children.\n"</span>, <span class="number">29</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"children 2 write %dB\n"</span>, n);</span><br><span class="line">        sem_post(write_mutex);</span><br><span class="line">        sem_post(read_mutex1);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第三个子进程并检查操作是否成功</span></span><br><span class="line">    CHECK((pid = fork()) >= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        sem_wait(write_mutex);</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        n = <span class="built_in">write</span>(pipefd[<span class="number">1</span>], <span class="string">"This is the third children.\n"</span>, <span class="number">28</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"children 3 write %dB\n"</span>, n);</span><br><span class="line">        sem_post(write_mutex);</span><br><span class="line">        sem_post(read_mutex2);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待第一个子进程运行完成，父进程继续运行</span></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置非阻塞性读，作为循环结束标志</span></span><br><span class="line">    fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">while</span> (!flag) {</span><br><span class="line">        n = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], str, BUF_MAX_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) {</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%dB read\n"</span>, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sem_post(write_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子进程二、三写入完毕</span></span><br><span class="line">    sem_wait(read_mutex1);</span><br><span class="line">    sem_wait(read_mutex2);</span><br><span class="line">    n = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], str, BUF_MAX_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dB read\n"</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < n; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sem_close(write_mutex);</span><br><span class="line">    sem_close(read_mutex1);</span><br><span class="line">    sem_close(read_mutex2);</span><br><span class="line">    sem_unlink(<span class="string">"pipe_test_wm"</span>);</span><br><span class="line">    sem_unlink(<span class="string">"pipe_test_rm_1"</span>);</span><br><span class="line">    sem_unlink(<span class="string">"pipe_test_rm_2"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里使用了三个信号量，分别是<code>write_mutex</code>、<code>read_mutex1</code>和<code>read_mutex2</code>，简单分析一下子进程和父进程之间的关系可以明白：</p>
<ul>
<li>子进程一先将64K的数据写入管道，父进程才能第一时间将数据全部读取出来（来自一进程的数据）</li>
<li>父进程将子进程一的数据读取之后，子进程二、三才能写入数据</li>
<li>子进程二、三将数据写入后，父进程随后才能读取第二批数据（来自二、三进程的数据）</li>
</ul>
<p>关系大致如下图所示：</p>
<div align="center">
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/04/2019-04-06-9032b3d.svg" alt></p>
</div>
<p><code>子进程写入数据1</code>和<code>父进程读取数据1</code>利用<code>wait(0)</code>限制了先后关系，父进程必须接收到子进程结束之后返回的0，才能继续运行，否则阻塞。</p>
<p><code>write_mutex</code>限制了父进程先读取数据，然后子进程二、三写入数据，<code>read_mutex1</code>和<code>read_mutex2</code>分别限制了子进程二、三写入数据2,3和父进程读取数据2,3先后关系，只有子进程二、三均完成后，父进程才允许读取管道。</p>
<p>子进程一使用了非阻塞性写，子进程二、三均为阻塞性写，父进程为非阻塞性读。</p>
<p>非阻塞写和非阻塞读的目的在于，阻塞写时，管道满了之后进程被阻塞，无法设置终止条件从而结束写，读也是一样，管道空了之后进程被阻塞，无法设置终止条件从而结束读。</p>
<p>进一步解释程序，除去复制了<code>fork</code>之前的程序运行空间，子进程一运行了第一个<code>if</code>中的代码块：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">1</span>], F_GETFL);</span><br><span class="line">    fcntl(pipefd[<span class="number">1</span>], F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">while</span> (!flag) {</span><br><span class="line">        n = <span class="built_in">write</span>(pipefd[<span class="number">1</span>], buf, BUF_MAX_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) {</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"children 1 write %dB\n"</span>, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"space = %dKB\n"</span>, (count * BUF_MAX_SIZE) / <span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>每次写入8K数据，直到管道满无法继续写入，<code>write</code>函数返回<code>-1</code>，循环终止，计数并打印出总数据大小——即管道容量。</p>
<hr>
<p>第二个子进程则运行了第二个<code>if</code>后的代码块：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">    sem_wait(write_mutex);</span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">    n = <span class="built_in">write</span>(pipefd[<span class="number">1</span>], <span class="string">"This is the second children.\n"</span>, <span class="number">29</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"children 2 write %dB\n"</span>, n);</span><br><span class="line">    sem_post(write_mutex);</span><br><span class="line">    sem_post(read_mutex1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>写入<code>This is the second children.\n</code>。</p>
<hr>
<p>第三个子进程则运行了第三个<code>if</code>后的代码块：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">    sem_wait(write_mutex);</span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">    n = <span class="built_in">write</span>(pipefd[<span class="number">1</span>], <span class="string">"This is the third children.\n"</span>, <span class="number">28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"children 3 write %dB\n"</span>, n);</span><br><span class="line">    sem_post(write_mutex);</span><br><span class="line">    sem_post(read_mutex2);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>写入<code>This is the third children.\n</code>。</p>
<hr>
<p>父进程运行了：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);</span><br><span class="line">    fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">while</span> (!flag) {</span><br><span class="line">        n = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], str, BUF_MAX_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) {</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%dB read\n"</span>, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sem_post(write_mutex);</span><br><span class="line"></span><br><span class="line">    sem_wait(read_mutex1);</span><br><span class="line">    sem_wait(read_mutex2);</span><br><span class="line">    n = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], str, BUF_MAX_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dB read\n"</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < n; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>line 2</code>至<code>line 14</code>用于读取子进程一写入的数据，否则子进程二、三无法继续写入，读空管道后结束循环，释放信号量，子进程二、三继续运行。</p>
<p><code>line 16</code>至<code>line 22</code>用于读取子进程二、三写入的数据，并打印到终端上，<code>BUF_MAX_SIZE</code>是想要读取的数据大小，<code>read</code>返回了实际读取的数据大小。</p>
<h2 id="实验结果" class="heading-control"><a class="heading-anchor" href="#实验结果" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h2>
<p>实验结果如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc Desktop/Untitled-1.c -o main -pthread</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./main</span></span><br><span class="line">children 1 write 8192B</span><br><span class="line">children 1 write 8192B</span><br><span class="line">children 1 write 8192B</span><br><span class="line">children 1 write 8192B</span><br><span class="line">children 1 write 8192B</span><br><span class="line">children 1 write 8192B</span><br><span class="line">children 1 write 8192B</span><br><span class="line">children 1 write 8192B</span><br><span class="line">space = 64KB</span><br><span class="line">8192B read</span><br><span class="line">8192B read</span><br><span class="line">8192B read</span><br><span class="line">8192B read</span><br><span class="line">8192B read</span><br><span class="line">8192B read</span><br><span class="line">8192B read</span><br><span class="line">8192B read</span><br><span class="line">children 2 write 29B</span><br><span class="line">children 3 write 28B</span><br><span class="line">57B read</span><br><span class="line">This is the second children.</span><br><span class="line">This is the third children.</span><br></pre></td></tr></tbody></table></figure>
<h2 id="相关阅读" class="heading-control"><a class="heading-anchor" href="#相关阅读" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#相关阅读"></a> 相关阅读</h2>
<ul>
<li>
<a href="/2019/01/os-lab1/" title="【OS】HDU-OS-Lab1-Linux内核编译及添加系统调用">【OS】HDU-OS-Lab1-Linux内核编译及添加系统调用</a>
</li>
<li>
<a href="/2019/03/os-lab2/" title="【OS】HDU-OS-Lab2-Linux内核模块编程">【OS】HDU-OS-Lab2-Linux内核模块编程</a>
</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【OS】HDU-OS-Lab1-Linux内核编译及添加系统调用</title>
    <url>/2019/01/os-lab1/</url>
    <content><![CDATA[<html><head></head><body><p>添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级prio。</p>
<blockquote>
<p>视频教程地址：</p>
<p><a href="https://www.bilibili.com/video/av47274857" target="_blank" rel="noopener">https://www.bilibili.com/video/av47274857</a></p>
<p>源码地址：</p>
<p><a href="https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab1" target="_blank" rel="noopener">https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab1</a></p>
</blockquote>
<a id="more"></a>
<p>以下内容全部在<code>Ubuntu 18.04</code>下操作，使用其他发行版的同学可在此基础上自行修改。</p>
<h2 id="实验内容" class="heading-control"><a class="heading-anchor" href="#实验内容" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2>
<ul>
<li>添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级prio。</li>
<li>写一个简单的应用程序测试添加的系统调用。</li>
<li>若程序中调用了Linux的内核函数，要求深入阅读相关函数源码。</li>
</ul>
<h2 id="准备工作" class="heading-control"><a class="heading-anchor" href="#准备工作" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2>
<h3 id="安装linux虚拟机" class="heading-control"><a class="heading-anchor" href="#安装linux虚拟机" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装linux虚拟机"></a> 安装Linux虚拟机</h3>
<blockquote>
<p>为免于重装系统，建议你使用VMware创建一个Linux虚拟机，在虚拟机下进行内核编译与安装，坏处是虚拟机的性能远不如主机，使得<strong>编译时长可能翻倍</strong>，好处是不管你怎么折腾，都<strong>不会弄坏自己的主机系统</strong>。</p>
</blockquote>
<ul>
<li>
<p>安装VMware，请查看这篇文章：<a href="/2019/02/ubuntu-config-vmware/">Ubuntu下配置VMware Workstation</a></p>
</li>
<li>
<p>安装虚拟机，请查看这篇文章：<a href="/2019/03/vmware-create-vm/">在VMware Workstation中创建虚拟机</a></p>
</li>
</ul>
<h3 id="获取内核源码" class="heading-control"><a class="heading-anchor" href="#获取内核源码" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#获取内核源码"></a> 获取内核源码</h3>
<p>从<a href="https://www.kernel.org" target="_blank" rel="noopener">The Linux Kernel Archives</a>获取Linux的内核源码，任意选择一个版本，建议使用<code>longterm</code>版本。</p>
<p>戳<a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.19.113.tar.xz" target="_blank" rel="noopener">这里</a>下载<code>linux-4.19.113.tar.xz</code>。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/02/2019-01-29-62088c7-1.png!on_blog" alt></p>
<h3 id="解压内核源码" class="heading-control"><a class="heading-anchor" href="#解压内核源码" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#解压内核源码"></a> 解压内核源码</h3>
<p>可以通过命令行或图形界面进行解压：</p>
<ul>
<li>
<p>右键单击内核压缩包，点击解压</p>
</li>
<li>
<p>或在终端键入如下命令检查文件是否存在。（系统语言为中文的请将<code>Downloads</code>替换为<code>下载</code>）。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Downloads</span><br><span class="line">$ tar xvJf linux-4.19.25.tar.xz</span><br></pre></td></tr></tbody></table></figure>
<p><code>tar</code>命令参数解释参见<a href="#tar">附录1-tar</a>.</p>
</li>
</ul>
<h2 id="修改内核" class="heading-control"><a class="heading-anchor" href="#修改内核" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#修改内核"></a> 修改内核</h2>
<h3 id="修改系统调用表" class="heading-control"><a class="heading-anchor" href="#修改系统调用表" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#修改系统调用表"></a> 修改系统调用表</h3>
<p>根据上一步内核源码解压目录，定位系统调用表：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将~/Downloads/linux-4.19.113替换为你的内核源码解压目录</span></span><br><span class="line">gedit ~/Downloads/linux-4.19.113/arch/x86/entry/syscalls/syscall_64.tbl</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到格式为：<code>"number" "abi" "name" "entry point"</code>。</p>
<p>定位到<code>common/64</code>的最后一条：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-9.png!on_blog" alt></p>
<p>在下面添加：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">335	64	mysetnice		__x64_sys_mysetnice</span><br></pre></td></tr></tbody></table></figure>
<h3 id="申明系统调用服务例程原型" class="heading-control"><a class="heading-anchor" href="#申明系统调用服务例程原型" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#申明系统调用服务例程原型"></a> 申明系统调用服务例程原型</h3>
<p>根据内核源码解压目录，定位系统调用头文件：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将~/Downloads/linux-4.19.113替换为你的内核源码解压目录</span></span><br><span class="line">gedit ~/Downloads/linux-4.19.113/include/linux/syscalls.h</span><br></pre></td></tr></tbody></table></figure>
<p>定位到最后一行：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-10.png!on_blog" alt></p>
<p>在<code>endif</code>前面添加系统调用原型声明：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_mysetnice</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> flag, <span class="keyword">int</span> nicevaluse, <span class="keyword">void</span> __user* prio, <span class="keyword">void</span> __user* nice)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="实现系统调用服务例程" class="heading-control"><a class="heading-anchor" href="#实现系统调用服务例程" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#实现系统调用服务例程"></a> 实现系统调用服务例程</h3>
<p>这一步与上一步的关系，就是C语言中头文件与实现文件的关系，上一步对函数进行了声明，这里给函数一个具体的实现。</p>
<blockquote>
<p>需要实现的任务为：</p>
<p>添加一个系统调用，对指定进程的nice值的修改及读取的功能，同时返回进程最新的nice值及优先级prio。</p>
<p>分解为四步：</p>
<ol>
<li>根据进程号pid找到相应的进程控制块PCB（因为进程控制块中记录了<strong>用于描述进程情况及控制进程运行所需要的全部信息</strong>，nice值和优先级正是其中的一部分）；</li>
<li>根据PCB读取它的nice值和优先级prio；</li>
<li>根据PCB对相应进程的nice值进行修改；</li>
<li>将得到的nice值和优先级prio进行返回。</li>
</ol>
</blockquote>
<p>根据内核源码解压目录，定位系统调用头文件：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将~/Downloads/linux-4.19.113替换为你的内核源码解压目录</span></span><br><span class="line">gedit ~/Downloads/linux-4.19.113/include/linux/syscalls.h</span><br></pre></td></tr></tbody></table></figure>
<p>定位到最后一行：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-12.png!on_blog" alt>在<code>endif</code>前面添加系统调用服务例程实现代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 置于sys.c的最末端（在‘#endif’之前</span></span><br><span class="line">SYSCALL_DEFINE5(mysetnice, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, flag, <span class="keyword">int</span>, nicevalue, <span class="keyword">void</span> __user *,</span><br><span class="line">                prio, <span class="keyword">void</span> __user *, nice) {</span><br><span class="line">    <span class="keyword">int</span> cur_prio, cur_nice;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">ppid</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pcb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过进程PID号找到进程的PID结构体，如果ppid为空指针则代表不存在与进程号与pid相同的进程，此时返回EFAULT（</span></span><br><span class="line">    <span class="comment">// 我编译的时候这个if判断并没有加进去，想做出上述判断的可以将注释删去，就逻辑本身而言没有问题-_-</span></span><br><span class="line">    <span class="comment">// 但我无法保证最后是否会出问题，因为我没有自己尝试过</span></span><br><span class="line">    ppid = find_get_pid(pid);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (ppid == NULL)</span></span><br><span class="line"><span class="comment">        return EFAULT;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过进程的PID结构体，找到与之对应的进程控制块</span></span><br><span class="line">    pcb = pid_task(ppid, PIDTYPE_PID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果flag=1则修改进程的nice值为nicevalue</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) {</span><br><span class="line">        set_user_nice(pcb, nicevalue);</span><br><span class="line">    }  <span class="comment">// flag既不为1也不为0的时候，即flag出错，此时返回EFAULT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flag != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> EFAULT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程当前的最新nice值和prio值</span></span><br><span class="line">    cur_prio = task_prio(pcb);</span><br><span class="line">    cur_nice = task_nice(pcb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于系统调用是在内核态下运行的，所有数据均为内核空间的数据，</span></span><br><span class="line">    <span class="comment">// 利用copy_to_user()函数将内核空间的数据复制到用户空间</span></span><br><span class="line">    copy_to_user(prio, &cur_prio, <span class="keyword">sizeof</span>(cur_prio));</span><br><span class="line">    copy_to_user(nice, &cur_nice, <span class="keyword">sizeof</span>(cur_nice));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要用到的几个内核函数：</p>
<ul>
<li><code>struct pid *find_get_pid(pid_t nr)</code>：根据进程标识符号返回相应的进程标识符</li>
<li><code>struct task_struct *pid_task(struct pid *pid, enum pid_type type)</code>：根据进程标识符和进程类型返回进程控制块</li>
<li><code>int task_prio(const struct task_struct *p)</code>：返回该PCB的prio参数</li>
<li><code>static inline int task_nice(const struct task_struct *p)</code>：返回该PCB的nice参数</li>
<li><code>void set_user_nice(struct task_struct *p, long nice)</code>：修改PCB的nice参数</li>
<li><code>static __always_inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n)</code>：将变量从内核空间复制到用户空间</li>
</ul>
<p>内核函数具体实现见<a href="#kfunc">附录2</a></p>
<h2 id="编译内核" class="heading-control"><a class="heading-anchor" href="#编译内核" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#编译内核"></a> 编译内核</h2>
<p>修改好内核后，开始进行编译。</p>
<h3 id="安装依赖" class="heading-control"><a class="heading-anchor" href="#安装依赖" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装依赖"></a> 安装依赖</h3>
<p>以下是一些需要用到的包，用apt/apt-get进行安装，命令行输入：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev make openssl libssl-dev bison flex libelf-dev</span><br></pre></td></tr></tbody></table></figure>
<h3 id="参数确认" class="heading-control"><a class="heading-anchor" href="#参数确认" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#参数确认"></a> 参数确认</h3>
<p>定位内核源码解压目录，命令行运行：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将~/Downloads/linux-4.19.113替换为你的内核源码解压目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/Downloads/linux-4.19.113</span><br></pre></td></tr></tbody></table></figure>
<p>命令行运行<code>make</code>，开始编译前的参数确认：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></tbody></table></figure>
<p>出现如下所示界面后，左右键移动下方光标选中<code>Save</code>，按<code>Enter</code>结束。</p>
<details>
<summary>点击展开详细步骤</summary>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-4.png!on_blog" alt></p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-5.png!on_blog" alt></p>
<p>点击<code>Ok</code>和之后出现的<code>Exit</code>。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-6.png!on_blog" alt></p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-7.png!on_blog" alt></p>
<p>左右键移动光标，选中<code>Exit</code>，<code>Enter</code>键结束这一步。</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-8.png!on_blog" alt></p>
</details>
<h3 id="编译" class="heading-control"><a class="heading-anchor" href="#编译" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3>
<p>编译内核需要耗费的时间较长，建议通电进行。</p>
<p>定位内核源码解压目录，命令行运行：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo make -j4 2> error.log</span><br></pre></td></tr></tbody></table></figure>
<p><code>-j4</code>表示使用四线程进行编译，这个过程大概持续一个小时，后面的重定向将错误信息输出到了<code>error.log</code>这个文件里面，方便之后进行错误排查。</p>
<blockquote>
<p><code>make</code>命令默认是指编译所有，包括内核和模块，所以不需要再重新使用<code>make modules</code>进行模块的编译（至少我并没有在这个地方受到困扰）。</p>
<p>如果碰到问题请查阅<a href="#qa">附录3</a>。</p>
</blockquote>
<h3 id="安装内核" class="heading-control"><a class="heading-anchor" href="#安装内核" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#安装内核"></a> 安装内核</h3>
<p>等待内核、模块均编译完成，开始安装内核，分为两步：</p>
<ul>
<li>
<p><strong>安装模块</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 大约持续十几分钟到几十分钟不等</span></span><br><span class="line">sudo make modules_install</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>替换内核</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 大约持续几分钟到十几分钟不等</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>替换完成后重启你的电脑，准备下一步的测试，如果电脑打不开可以参考<a href="#q-a">附录3</a>。</p>
<h2 id="测试" class="heading-control"><a class="heading-anchor" href="#测试" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2>
<p>完成编译工作后，需要编写一个用户态程序，测试系统调用是否正常工作，这里直接给出<code>demo.c</code>，请自行查阅理解。</p>
<figure class="highlight c"><figcaption><span>demo.c</span><a href="https://github.com/leslievan/Operator_System/raw/master/Operator_System_Lab1/demo.c" target="_blank" rel="noopener">link</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// demo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/syscall.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SYSCALL_MYSETNICE_ 335</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFALUT 14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> pid, flag, nicevalue;</span><br><span class="line">    <span class="keyword">int</span> prev_prio, prev_nice, cur_prio, cur_nice;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input variable(pid, flag, nicevalue): "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &pid, &flag, &nicevalue);</span><br><span class="line">    </span><br><span class="line">    result = syscall(_SYSCALL_MYSETNICE_, pid, <span class="number">0</span>, nicevalue, &prev_prio,</span><br><span class="line">                     &prev_nice);</span><br><span class="line">    <span class="keyword">if</span> (result == EFALUT)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        syscall(_SYSCALL_MYSETNICE_, pid, <span class="number">1</span>, nicevalue, &cur_prio, &cur_nice);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Original priority is: [%d], original nice is [%d]\n"</span>, prev_prio,</span><br><span class="line">               prev_nice);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Current priority is : [%d], current nice is [%d]\n"</span>, cur_prio,</span><br><span class="line">               cur_nice);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Current priority is : [%d], current nice is [%d]\n"</span>, prev_prio,</span><br><span class="line">               prev_nice);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>命令行使用<code>gcc</code>进行编译，根据提示信息输入<code>pid</code>、<code>flag</code>和<code>nicevalue</code>进行测试。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将~/demo.c替换为你的demo.c所在位置</span></span><br><span class="line">gcc ~/demo.c -o demo</span><br><span class="line">./demo</span><br></pre></td></tr></tbody></table></figure>
<h2 id="附录" class="heading-control"><a class="heading-anchor" href="#附录" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2>
<h3 id="a-idtara附录1tar" class="heading-control"><a class="heading-anchor" href="#a-idtara附录1tar" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#a-idtara附录1tar"></a> <a id="tar"></a>附录1：tar</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">tar xvJf linux-4.19.133.tar.bz</span><br></pre></td></tr></tbody></table></figure>
<p>tar命令可以为linux的文件和目录创建档案，利用tar可以把一大堆的文件和目录全部打包成一个文件。</p>
<ul>
<li>-x或–extract或–get：从备份文件中还原文件，即解压</li>
<li>-v：显示操作过程，即显示进度</li>
<li>-j：支持bzip2解压文件，即解压tar.bz文件</li>
<li>-f<备份文件>或–file=<备份文件>：指定备份文件，即解压对应路径的文件</li>
</ul>
<h3 id="a-idkfunca附录2内核函数" class="heading-control"><a class="heading-anchor" href="#a-idkfunca附录2内核函数" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#a-idkfunca附录2内核函数"></a> <a id="kfunc"></a>附录2：内核函数</h3>
<div class="tabs" id="source_code"><ul class="nav-tabs"><li class="tab active"><a href="#source_code-1">find_get_pid</a></li><li class="tab"><a href="#source_code-2">pid_task</a></li><li class="tab"><a href="#source_code-3">task_prio</a></li><li class="tab"><a href="#source_code-4">task_nice</a></li><li class="tab"><a href="#source_code-5">set_user_nice</a></li><li class="tab"><a href="#source_code-6">copy_to_user</a></li></ul><div class="tab-content"><div class="tab-pane active" id="source_code-1"><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">struct pid *<span class="title">find_get_pid</span><span class="params">(<span class="keyword">pid_t</span> nr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	pid = get_pid(find_vpid(nr));</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="source_code-2"><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">pid_task</span><span class="params">(struct pid *pid, <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">result</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (pid) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">		first = rcu_dereference_check(hlist_first_rcu(&pid->tasks[type]),</span><br><span class="line">					      lockdep_tasklist_lock_is_held());</span><br><span class="line">		<span class="keyword">if</span> (first)</span><br><span class="line">			result = hlist_entry(first, struct task_struct, pid_links[(type)]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="source_code-3"><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">task_prio</span><span class="params">(<span class="keyword">const</span> struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> p->prio - MAX_RT_PRIO;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="source_code-4"><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">task_nice</span><span class="params">(<span class="keyword">const</span> struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> PRIO_TO_NICE((p)->static_prio);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="source_code-5"><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_user_nice</span><span class="params">(struct task_struct *p, <span class="keyword">long</span> nice)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">bool</span> queued, <span class="built_in">running</span>;</span><br><span class="line">	<span class="keyword">int</span> old_prio, delta;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have to be careful, if called from sys_setpriority(),</span></span><br><span class="line"><span class="comment">	 * the task might be in the middle of scheduling on another CPU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq = task_rq_lock(p, &rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The RT priorities are set via sched_setscheduler(), but we still</span></span><br><span class="line"><span class="comment">	 * allow the 'normal' nice value to be set - but as expected</span></span><br><span class="line"><span class="comment">	 * it wont have any effect on scheduling until the task is</span></span><br><span class="line"><span class="comment">	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p) || task_has_rt_policy(p)) {</span><br><span class="line">		p->static_prio = NICE_TO_PRIO(nice);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	}</span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	<span class="built_in">running</span> = task_current(rq, p);</span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">running</span>)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	p->static_prio = NICE_TO_PRIO(nice);</span><br><span class="line">	set_load_weight(p, <span class="literal">true</span>);</span><br><span class="line">	old_prio = p->prio;</span><br><span class="line">	p->prio = effective_prio(p);</span><br><span class="line">	delta = p->prio - old_prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued) {</span><br><span class="line">		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the task increased its priority or is running and</span></span><br><span class="line"><span class="comment">		 * lowered its priority, then reschedule its CPU:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (delta < <span class="number">0</span> || (delta > <span class="number">0</span> && task_running(rq, p)))</span><br><span class="line">			resched_curr(rq);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">running</span>)</span><br><span class="line">		set_curr_task(rq, p);</span><br><span class="line">out_unlock:</span><br><span class="line">	task_rq_unlock(rq, p, &rf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="source_code-6"><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">unsigned</span> <span class="keyword">long</span> __must_check <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (likely(check_copy_size(from, n, <span class="literal">true</span>)))</span><br><span class="line">		n = _copy_to_user(to, from, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div></div>
<h3 id="a-idqaa附录3qa" class="heading-control"><a class="heading-anchor" href="#a-idqaa附录3qa" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#a-idqaa附录3qa"></a> <a id="qa"></a>附录3：Q&A</h3>
<div class="note warning">
            <p>每次出现错误后都需要执行<code>sudo make clean</code>清除残余文件！<br>每次出现错误后都需要执行<code>sudo make clean</code>清除残余文件！<br>每次出现错误后都需要执行<code>sudo make clean</code>清除残余文件！</p>
          </div>
<div class="note primary">
            <p>Q：在完成所有步骤重启系统时，提示：<code>Kernel panic - not syncing: System is deadlocked on memory</code></p><p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2019/03/2019-01-29-62088c7-2.png!on_blog" alt="ERROR1"></p>A：原因是只给虚拟机分配了2G的内存，导致了系统在内存上的死锁，<strong>将虚拟机内存扩充至4G</strong>后解决。
          </div>
<div class="note primary">
            <p>Q：编译时提示<code>gcc: error: unrecognized command line option '-fno-plt'</code>，如下所示：</p><p>​```bash<br>HOSTCC  scripts/selinux/genheaders/genheaders<br>HOSTCC  scripts/selinux/mdp/mdp<br>gcc: error: unrecognized command line option ‘-fno-plt’<br>gcc: error: unrecognized command line option ‘-fno-plt’<br>HOSTCC   /root/linux52/linux-5.2.13/tools/objtool/fixdep.o<br>HOSTLD   /root/linux52/linux-5.2.13/tools/objtool/fixdep-in.o<br>LINK     /root/linux52/linux-5.2.13/tools/objtool/fixdep<br>CC       /root/linux52/linux-5.2.13/tools/objtool/arch/x86/decode.o<br>gcc: error: unrecognized command line option ‘-fno-plt’</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">A：原因是<code>gcc</code>版本过低，<code>-fno-plt</code>标志是<code>gcc6</code>才提出的，可以用命令<code>gcc --version</code>查看自己的版本。可以先尝试使用<code>sudo apt-get install gcc6</code>，但在部分系统中，并未收录<code>gcc6</code>，如果直接安装的方法无效，显示无法定位软件包的话，可以采用手动添加PPA的方法：</span><br><span class="line">```bash</span><br><span class="line">$ curl https://gist.githubusercontent.com/leslievan/3c2872d7b375c22a2df60c57dbf7bd27/raw/8ef3b032797b03dec824707ad6294aa43301ab8d/ubuntu-install-gcc-6 | bash</span><br></pre></td></tr></tbody></table></figure>
          </div>
<div class="note primary">
            <p>Q：编译时提示<code>/bin/sh: 1: bc: not found</code>，如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"> CALL    scripts/atomic/check-atomics.sh</span><br><span class="line">/bin/sh: 1: bc: not found</span><br><span class="line">Kbuild:26: recipe <span class="keyword">for</span> target <span class="string">'include/generated/timeconst.h'</span> failed</span><br><span class="line">make[1]: *** [include/generated/timeconst.h] Error 127</span><br><span class="line">make[1]: *** 正在等待未完成的任务....</span><br></pre></td></tr></tbody></table></figure><p>A：原因是没有安装<code>bc</code>，执行<code>sudo apt-get install bc</code>将它安装上即可，出现类似的<code>xxx: not found</code>的错误都可以尝试使用<code>sudo apt-get install xxx</code>安装后再次尝试。</p>
          </div>
<h2 id="相关阅读" class="heading-control"><a class="heading-anchor" href="#相关阅读" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#相关阅读"></a> 相关阅读</h2>
<ul>
<li>
<a href="/2019/03/os-lab2/" title="【OS】HDU-OS-Lab2-Linux内核模块编程">【OS】HDU-OS-Lab2-Linux内核模块编程</a>
</li>
<li>
<a href="/2019/04/os-lab-3-2/" title="【OS】HDU-OS-Lab3-Linux进程管理（二）管道通信">【OS】HDU-OS-Lab3-Linux进程管理（二）管道通信</a>
</li>
<li>
<a href="/2019/04/os-lab-3-3/" title="【OS】HDU-OS-Lab3-Linux进程管理（三）进程通信">【OS】HDU-OS-Lab3-Linux进程管理（三）进程通信</a>
</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【OS】HDU-OS-Lab3-Linux进程管理（三）消息队列</title>
    <url>/2019/04/os-lab-3-3/</url>
    <content><![CDATA[<html><head></head><body><p>实验三的知识点是进程通信，进程通信的方式多种多样，既包括锁机制、信号量机制在内的低级通信方式，低级在于其交换的信息量少且效率较低，又包括共享服务器、消息传递系统、管道通信以及客户-服务器系统通信在内的高级通信方式，本实验是实验三的第三个部分，介绍了利用消息队列通信机制实现两个线程间通信的方法。</p>
<blockquote>
<p>源码地址：</p>
<p><a href="https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab3/Operator_System_Exp3_3" target="_blank" rel="noopener">https://github.com/leslievan/Operator_System/tree/master/Operator_System_Lab3/Operator_System_Exp3_3</a></p>
</blockquote>
<a id="more"></a>
<a class="btn" href="https://leslie-cloud.oss-accelerate.aliyuncs.com/files/Operate_System/Operator_System_Lab1.tar.xz" target="_blank" rel="noopener">
            <i class="fa fa-"></i>点此下载完整源码
          </a>
<h2 id="基本介绍" class="heading-control"><a class="heading-anchor" href="#基本介绍" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#基本介绍"></a> 基本介绍</h2>
<p>消息缓冲队列通信机制是消息传递系统通信中直接通信方式的一种具体实现，基本思想为：通常由系统一管理一组用于通信的空闲消息缓冲区；某进程要发送消息时，首先在自己的地址空间中设置一个发送区，并把欲发送的消息填入其中形成消息，再申请一个消息缓冲区，把数据从发送区复制到消息缓冲区中，然后再把该消息缓冲区直接发送到接收进程的消息队列里；接收进程从自己的消息队列上取下消息缓冲区，并将其中的数据复制到自己的消息接收区中，最后释放消息缓冲区。</p>
<h2 id="实验内容" class="heading-control"><a class="heading-anchor" href="#实验内容" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2>
<blockquote>
<p><strong>利用Linux的消息队列通信机制实现两个线程间的通信</strong></p>
<p>编写程序创建三个线程：<code>sender1</code>线程、<code>sender2</code>线程和<code>receive</code>线程，三个线程的功能描述如下：</p>
<ol>
<li><code>sender1</code>线程：允许函数<code>sender1()</code>，它创建一个消息队列，然后等待用户通过终端输入一串字符，并将这串字符通过消息队列发送给<code>receiver</code>线程；可循环发送多个消息，直到用户输入“exit”为止，表示它不再发送消息，最后向<code>receiver</code>线程发送消息“end1”，并且等待 receiver的应答，等到应答消息后，接收到的应答信息显示在终端屏幕上，结束线程的运行。</li>
<li><code>sender2</code>线程：运行函数<code>sender2()</code>，共享<code>sender1</code>创建的消息队列，等待用户通过终端输入一串字符，并将这串字符通过消息队列发送给<code>receiver</code>线程；可循环发送多个消息，直到用户输入“exit”为止，表示它不再发送消息，最后向<code>receiver</code>线程发送消息“end2“，并且等待 <code>receiver</code>的应答，等到应答消息后将接收到的应答信息显示在终端屏幕上，结束线程的运行。</li>
<li><code>Receiver</code>线程：运行函数<code>receive()</code>，它通过消息队列接收来自<code>sender1</code>和<code>sender2</code>两个线程的消息，将消息显示在终端屏幕上，当收到内容为“end1”的消息时，就向<code>sender1</code>发送一个应答消息“over1”；当收到内容为“end2”的消息时，就向<code>sender2</code>发送一个应答消息“over2”；消息接收完成后删除消息队列，结束线程的运行。选择合适的信号量机制实现三个线程之间的同步与互斥。</li>
</ol>
</blockquote>
<p>该实验主要难点在于消息队列的相关操作函数和对于三个线程之间的同步互斥关系。</p>
<h3 id="消息队列" class="heading-control"><a class="heading-anchor" href="#消息队列" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h3>
<p>消息队列需要自定义一个消息缓冲区，这里设计一个只包含两个成员变量的结构体作为消息缓冲区：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> {</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> message_type;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[MAX_SIZE + <span class="number">1</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>message_type</code>为消息种类，<code>buffer</code>用来储存消息的数据段，最大可存储<code>MAX_SIZE</code>大小，<code>+1</code>操作为了给结尾留出<code>\0</code>。</p>
<p>消息队列的相关操作有：</p>
<ol>
<li><code>int msgget(key_t key, int msgflg);</code>获得消息队列的特征标识符。<br>
函数需要两个参数，<code>key</code>和<code>msgflg</code>。<br>
<code>key</code>是该消息队列的全局唯一标识符，通过该标识符可以定位消息队列，对其进行相关操作。<br>
<code>msgflg</code>为权限控制，决定对消息队列进行的操作，一般使用<code>0666 | IPC_CREAT</code>，熟悉文件系统的可以知道，<code>0666</code>表示文件所有者、同组用户和其他用户对于该消息队列的权限均为可读可写，后面对常量<code>IPC_CREAT</code>进行的位运算作用是“若该队列未被创建则创建它”。<em>（对于该函数可以简单理解为创建消息队列）</em></li>
<li><code>ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);</code>消息队列的接收操作。<br>
函数需要五个参数，<code>msqid</code>，<code>msgp</code>，<code>msgsz</code>，<code>msgtyp</code>和<code>msgflg</code>。<br>
<code>msqid</code>是函数<code>msgget</code>的返回值，用于表示对哪一个消息队列进行操作。<br>
<code>msgp</code>是接收消息的指针，指向消息结构体<code>msg_st</code>。<br>
<code>msgsz</code>是接收消息的大小，这里可以看作结构体<code>msg_st</code>中数据段的大小。<br>
<code>msgtyp</code>是接收消息的类别，函数可以接收指定类别的消息，默认为0，忽视类别，接收队首消息，正值和负值有不同含义，详情查看<a href="#%E9%99%84%E5%BD%95">附录</a>。<br>
<code>msgflg</code>同函数<code>msgget</code>中的<code>msgflg</code>，这里可以直接使用<code>0</code>。<br>
函数的返回值为实际接收到的消息字节数。</li>
<li><code>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</code>消息队列的发送操作。<br>
函数需要四个参数，<code>msqid</code>，<code>msgp</code>，<code>msgsz</code>和<code>msgflg</code>。<br>
参数含义可参考函数<code>msgrcv</code>。</li>
<li><code>int msgctl(int msqid, int cmd, struct msqid_ds *buf);</code>消息队列的控制操作。<br>
函数需要三个参数，<code>msqid</code>，<code>cmd</code>和<code>buf</code>。<br>
<code>msqid</code>同上。<br>
<code>cmd</code>对消息队列的操作进行选择，需要用到的是<code>IPC_RMID</code>，用于移除<code>msqid</code>指向的消息队列，详情查看<a href="#%E9%99%84%E5%BD%95">附录</a>。<br>
<code>buf</code>为消息队列进行操作的参数，这里不需用到，详情请查看<a href="#%E9%99%84%E5%BD%95">附录</a>。</li>
</ol>
<p><strong>这部分书上应该更详细，可以看书。</strong></p>
<figure class="highlight c"><figcaption><span>demo</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">ssize_t</span> bytes_read, bytes_write;</span><br><span class="line"><span class="keyword">int</span> MAX_SIZE = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a queue / Get a queue </span></span><br><span class="line"><span class="comment"> * int msgget(key_t key, int msgflg)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mq = msgget((<span class="keyword">key_t</span>) QUEUE_ID, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get message from queue, place the message to buf</span></span><br><span class="line"><span class="comment"> * ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bytes_read = msgrcv(mq, (<span class="keyword">void</span> *) &buf, MAX_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* Get specific type message, such like 1 */</span></span><br><span class="line">bytes_read = msgrcv(mq, (<span class="keyword">void</span> *) &buf, MAX_SIZE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send message to queue with message in buf</span></span><br><span class="line"><span class="comment"> * int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bytes_read = msgrcv(mq, (<span class="keyword">void</span> *) &buf, MAX_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* Send specific type message, suck like 1 */</span></span><br><span class="line">bytes_read = msgrcv(mq, (<span class="keyword">void</span> *) &buf, MAX_SIZE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove(Destroy) the queue</span></span><br><span class="line"><span class="comment"> * int msgctl(int msqid, int cmd, struct msqid_ds *buf)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">msgctl(mq, IPC_RMID, &t);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="同步互斥关系" class="heading-control"><a class="heading-anchor" href="#同步互斥关系" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#同步互斥关系"></a> 同步互斥关系</h3>
<p><code>sender</code>和<code>receiver</code>之间的进程同步比较简单，临界资源为消息队列。是有：</p>
<ol>
<li><code>receiver</code>接收消息，<code>sender</code>发送消息，<code>receiver</code>和<code>sender</code>存在同步关系，使用<code>full=0</code>和<code>empty=1</code>进行约束；</li>
<li><code>sender</code>之间存在互斥关系，两个发送线程不能同时工作 ，使用<code>w_mutex=1</code>进行约束；</li>
<li><code>receiver</code>等待发送进程结束后，返回应答，<code>sender</code>收到应答后进行输出，<code>receiver</code>和<code>sender</code>存在同步关系，使用<code>over=0</code>进行约束；</li>
<li>这里对于终端输出也进行了约束，使用<code>rcv_dp</code>和<code>snd_dp</code>进行约束，可以忽视这部分的处理，这一部分只是为了美观。</li>
</ol>
<h3 id="代码实现" class="heading-control"><a class="heading-anchor" href="#代码实现" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3>
<h4 id="发送线程" class="heading-control"><a class="heading-anchor" href="#发送线程" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#发送线程"></a> 发送线程</h4>
<figure class="highlight c"><figcaption><span>sender1</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sender1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> mq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> bytes_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open the mail queue */</span></span><br><span class="line">    mq = msgget((<span class="keyword">key_t</span>) QUEUE_ID, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    CHECK((<span class="keyword">key_t</span>) <span class="number">-1</span> != mq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        P(w_mutex);		<span class="comment">/* 进入互斥区 */</span></span><br><span class="line">        P(snd_dp);		<span class="comment">/* 这部分只是为了美观 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sender1> "</span>);</span><br><span class="line">        V(rcv_dp);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        </span><br><span class="line">        fgets(buf.<span class="built_in">buffer</span>, BUFSIZ, <span class="built_in">stdin</span>);	<span class="comment">/* 接收终端输入，置入buf.buffer */</span></span><br><span class="line">        buf.message_type = snd_to_rcv1;		<span class="comment">/* 设置消息类别，接收线程据此判断消息来源 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* send the message */</span></span><br><span class="line">        P(empty);		<span class="comment">/* 使用empty和full进行同步 */</span></span><br><span class="line">        CHECK(<span class="number">0</span> <= msgsnd(mq, (<span class="keyword">void</span>*)&buf, MAX_SIZE, <span class="number">0</span>));	<span class="comment">/* Check用于检测参数是否成立，不成立则报错，用于Debug，可忽视其实现，作为宏定义，定义在头文件中 */</span></span><br><span class="line">        V(full);</span><br><span class="line">        V(w_mutex);</span><br><span class="line">        <span class="comment">/* 换行为了使线程随机切换，勿随意删除 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">     } <span class="keyword">while</span> (<span class="built_in">strncmp</span>(buf.<span class="built_in">buffer</span>, MSG_STOP, <span class="built_in">strlen</span>(MSG_STOP)));	<span class="comment">/* Terminate when receive 'exit' */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait for response */</span></span><br><span class="line">    P(over);</span><br><span class="line">    bytes_read = msgrcv(mq, (<span class="keyword">void</span> *) &buf, MAX_SIZE, rcv_to_snd1, <span class="number">0</span>);</span><br><span class="line">    CHECK(bytes_read >= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf.<span class="built_in">buffer</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--------------------------------------------\n"</span>);</span><br><span class="line">    V(snd_dp);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="接收线程" class="heading-control"><a class="heading-anchor" href="#接收线程" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#接收线程"></a> 接收线程</h4>
<figure class="highlight c"><figcaption><span>receiver</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">receiver</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">buf</span>, <span class="title">over1</span>, <span class="title">over2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> mq, must_stop = <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">t</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 定义两个结束信号 */</span></span><br><span class="line">    over1.message_type = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(over1.<span class="built_in">buffer</span>, <span class="string">"over1\n"</span>);</span><br><span class="line">    over2.message_type = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(over2.<span class="built_in">buffer</span>, <span class="string">"over2\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open the mail queue */</span></span><br><span class="line">    mq = msgget((<span class="keyword">key_t</span>) QUEUE_ID, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    CHECK((<span class="keyword">key_t</span>) <span class="number">-1</span> != mq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">ssize_t</span> bytes_read, bytes_write;</span><br><span class="line">        <span class="comment">/* receive the message */</span></span><br><span class="line">        P(full);</span><br><span class="line">        bytes_read = msgrcv(mq, (<span class="keyword">void</span> *) &buf, MAX_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        V(empty);</span><br><span class="line">        </span><br><span class="line">        CHECK(bytes_read >= <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 接收到"exit"信号 */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(buf.<span class="built_in">buffer</span>, MSG_STOP, <span class="built_in">strlen</span>(MSG_STOP))) {</span><br><span class="line">            <span class="keyword">if</span> (buf.message_type == <span class="number">1</span>) {</span><br><span class="line">                <span class="comment">/* 写入并发送退出消息 */</span></span><br><span class="line">                bytes_write = msgsnd(mq, (<span class="keyword">void</span> *) &over1, MAX_SIZE, <span class="number">0</span>);</span><br><span class="line">                CHECK(bytes_write >= <span class="number">0</span>);</span><br><span class="line">                V(over);</span><br><span class="line">                must_stop--;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (buf.message_type == <span class="number">2</span>) {</span><br><span class="line">                <span class="comment">/* 写入并发送退出消息 */</span></span><br><span class="line">                bytes_write = msgsnd(mq, (<span class="keyword">void</span> *) &over2, MAX_SIZE, <span class="number">0</span>);</span><br><span class="line">                CHECK(bytes_write >= <span class="number">0</span>);</span><br><span class="line">                V(over);</span><br><span class="line">                must_stop--;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/* 正常处理消息 */</span></span><br><span class="line">            P(rcv_dp);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Received%d: %s"</span>, buf.message_type, buf.<span class="built_in">buffer</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"--------------------------------------------\n"</span>);</span><br><span class="line">            V(snd_dp);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">while</span> (must_stop); <span class="comment">/* Terminate when no thread */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cleanup */</span></span><br><span class="line">    P(snd_dp);</span><br><span class="line">    CHECK(!msgctl(mq, IPC_RMID, &t));</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实验结果" class="heading-control"><a class="heading-anchor" href="#实验结果" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h2>
<p>实验结果如下：</p>
<p><img data-src="https://leslie-cloud.oss-accelerate.aliyuncs.com/2020/05/2019-04-os-lab-3-1.png?x-oss-process=style/on_blog" alt="Result"></p>
<h2 id="附录" class="heading-control"><a class="heading-anchor" href="#附录" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2>
<p><strong><code>msgrcv</code></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">MSGRCV(3P)                   POSIX Programmer's Manual                   MSGRCV(3P)</span><br><span class="line"></span><br><span class="line">PROLOG</span><br><span class="line">       This manual page is part of the POSIX Programmer's Manual.  The Linux imple‐</span><br><span class="line">       mentation of this interface may differ (consult the corresponding Linux man‐</span><br><span class="line">       ual  page for details of Linux behavior), or the interface may not be imple‐</span><br><span class="line">       mented on Linux.</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       msgrcv — XSI message receive operation</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include <sys/msg.h></span><br><span class="line"></span><br><span class="line">       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,</span><br><span class="line">           int msgflg);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The msgrcv() function operates on XSI message queues (see the  Base  Defini‐</span><br><span class="line">       tions volume of POSIX.1‐2008, Section 3.225, Message Queue).  It is unspeci‐</span><br><span class="line">       fied whether this function interoperates with the realtime interprocess com‐</span><br><span class="line">       munication facilities defined in Section 2.8, Realtime.</span><br><span class="line"></span><br><span class="line">       The  msgrcv()  function  shall read a message from the queue associated with</span><br><span class="line">       the message queue identifier specified by msqid and place it in the user-de‐</span><br><span class="line">       fined buffer pointed to by msgp.</span><br><span class="line"></span><br><span class="line">       The application shall ensure that the argument msgp points to a user-defined</span><br><span class="line">       buffer that contains first a field of type long specifying the type  of  the</span><br><span class="line">       message,  and  then a data portion that holds the data bytes of the message.</span><br><span class="line">       The structure below is an example of what  this  user-defined  buffer  might</span><br><span class="line">       look like:</span><br><span class="line"></span><br><span class="line">           struct mymsg {</span><br><span class="line">               long    mtype;     /* Message type. */</span><br><span class="line">               char    mtext[1];  /* Message text. */</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">       The  structure  member  mtype is the received message's type as specified by</span><br><span class="line">       the sending process.</span><br><span class="line"></span><br><span class="line">       The structure member mtext is the text of the message.</span><br><span class="line"></span><br><span class="line">       The argument msgsz specifies the size in bytes of mtext.  The received  mes‐</span><br><span class="line">       sage  shall  be truncated to msgsz bytes if it is larger than msgsz and (ms‐</span><br><span class="line">       gflg & MSG_NOERROR) is non-zero.  The truncated part of the message shall be</span><br><span class="line">       lost  and  no  indication  of  the  truncation shall be given to the calling</span><br><span class="line">       process.</span><br><span class="line"></span><br><span class="line">       If the value of msgsz is greater than {SSIZE_MAX}, the result is implementa‐</span><br><span class="line">       tion-defined.</span><br><span class="line"></span><br><span class="line">       The argument msgtyp specifies the type of message requested as follows:</span><br><span class="line"></span><br><span class="line">        *  If msgtyp is 0, the first message on the queue shall be received.</span><br><span class="line"></span><br><span class="line">        *  If  msgtyp  is greater than 0, the first message of type msgtyp shall be</span><br><span class="line">           received.</span><br><span class="line"></span><br><span class="line">        *  If msgtyp is less than 0, the first message of the lowest type  that  is</span><br><span class="line">           less than or equal to the absolute value of msgtyp shall be received.</span><br><span class="line"></span><br><span class="line">       The argument msgflg specifies the action to be taken if a message of the de‐</span><br><span class="line">       sired type is not on the queue. These are as follows:</span><br><span class="line"></span><br><span class="line">        *  If (msgflg & IPC_NOWAIT) is non-zero, the calling  thread  shall  return</span><br><span class="line">           immediately with a return value of −1 and errno set to [ENOMSG].</span><br><span class="line"></span><br><span class="line">        *  If  (msgflg  & IPC_NOWAIT) is 0, the calling thread shall suspend execu‐</span><br><span class="line">           tion until one of the following occurs:</span><br><span class="line"></span><br><span class="line">           --  A message of the desired type is placed on the queue.</span><br><span class="line"></span><br><span class="line">           --  The message queue identifier msqid is removed from the system;  when</span><br><span class="line">               this occurs, errno shall be set to [EIDRM] and −1 shall be returned.</span><br><span class="line"></span><br><span class="line">           --  The  calling  thread receives a signal that is to be caught; in this</span><br><span class="line">               case a message is not received and the calling thread resumes execu‐</span><br><span class="line">               tion in the manner prescribed in sigaction().</span><br><span class="line"></span><br><span class="line">       Upon  successful completion, the following actions are taken with respect to</span><br><span class="line">       the data structure associated with msqid:</span><br><span class="line"></span><br><span class="line">        *  msg_qnum shall be decremented by 1.</span><br><span class="line"></span><br><span class="line">        *  msg_lrpid shall be set to the process ID of the calling process.</span><br><span class="line"></span><br><span class="line">        *  msg_rtime shall be set to the current  time,  as  described  in  Section</span><br><span class="line">           2.7.1, IPC General Description.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       Upon  successful completion, msgrcv() shall return a value equal to the num‐</span><br><span class="line">       ber of bytes actually placed into the buffer mtext.  Otherwise,  no  message</span><br><span class="line">       shall be received, msgrcv() shall return −1, and errno shall be set to indi‐</span><br><span class="line">       cate the error.</span><br></pre></td></tr></tbody></table></figure>
<p><strong><code>msgctl</code></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">MSGCTL(3P)                   POSIX Programmer's Manual                   MSGCTL(3P)</span><br><span class="line"></span><br><span class="line">PROLOG</span><br><span class="line">       This manual page is part of the POSIX Programmer's Manual.  The Linux imple‐</span><br><span class="line">       mentation of this interface may differ (consult the corresponding Linux man‐</span><br><span class="line">       ual  page for details of Linux behavior), or the interface may not be imple‐</span><br><span class="line">       mented on Linux.</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       msgctl — XSI message control operations</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include <sys/msg.h></span><br><span class="line"></span><br><span class="line">       int msgctl(int msqid, int cmd, struct msqid_ds *buf);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The msgctl() function operates on XSI message queues (see the  Base  Defini‐</span><br><span class="line">       tions volume of POSIX.1‐2008, Section 3.225, Message Queue).  It is unspeci‐</span><br><span class="line">       fied whether this function interoperates with the realtime interprocess com‐</span><br><span class="line">       munication facilities defined in Section 2.8, Realtime.</span><br><span class="line"></span><br><span class="line">       The  msgctl() function shall provide message control operations as specified</span><br><span class="line">       by cmd.  The following values for cmd, and the  message  control  operations</span><br><span class="line">       they specify, are:</span><br><span class="line"></span><br><span class="line">       IPC_STAT    Place  the  current  value  of  each member of the msqid_ds data</span><br><span class="line">                   structure associated with msqid into the structure pointed to by</span><br><span class="line">                   buf.  The contents of this structure are defined in <sys/msg.h>.</span><br><span class="line"></span><br><span class="line">       IPC_SET     Set  the  value  of  the  following members of the msqid_ds data</span><br><span class="line">                   structure associated with msqid to the corresponding value found</span><br><span class="line">                   in the structure pointed to by buf:</span><br><span class="line"></span><br><span class="line">                       msg_perm.uid</span><br><span class="line">                       msg_perm.gid</span><br><span class="line">                       msg_perm.mode</span><br><span class="line">                       msg_qbytes</span><br><span class="line"></span><br><span class="line">                   Also,  the msg_ctime timestamp shall be set to the current time,</span><br><span class="line">                   as described in Section 2.7.1, IPC General Description.</span><br><span class="line"></span><br><span class="line">                   IPC_SET can only be executed by a process with appropriate priv‐</span><br><span class="line">                   ileges  or  that  has an effective user ID equal to the value of</span><br><span class="line">                   msg_perm.cuid or msg_perm.uid in the msqid_ds data structure as‐</span><br><span class="line">                   sociated with msqid.  Only a process with appropriate privileges</span><br><span class="line">                   can raise the value of msg_qbytes.</span><br><span class="line"></span><br><span class="line">       IPC_RMID    Remove the message queue identifier specified by msqid from  the</span><br><span class="line">                   system and destroy the message queue and msqid_ds data structure</span><br><span class="line">                   associated with it. IPC_RMD can only be executed  by  a  process</span><br><span class="line">                   with appropriate privileges or one that has an effective user ID</span><br><span class="line">                   equal to the value  of  msg_perm.cuid  or  msg_perm.uid  in  the</span><br><span class="line">                   msqid_ds data structure associated with msqid.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       Upon successful completion, msgctl() shall return 0; otherwise, it shall re‐</span><br><span class="line">       turn −1 and set errno to indicate the error.</span><br></pre></td></tr></tbody></table></figure>
<h2 id="相关阅读" class="heading-control"><a class="heading-anchor" href="#相关阅读" aria-hidden="true"></a><a class="markdownIt-Anchor" href="#相关阅读"></a> 相关阅读</h2>
<ul>
<li>
<a href="/2019/01/os-lab1/" title="【OS】HDU-OS-Lab1-Linux内核编译及添加系统调用">【OS】HDU-OS-Lab1-Linux内核编译及添加系统调用</a>
</li>
<li>
<a href="/2019/03/os-lab2/" title="【OS】HDU-OS-Lab2-Linux内核模块编程">【OS】HDU-OS-Lab2-Linux内核模块编程</a>
</li>
<li>
</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
